<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on To be a sailor</title>
    <link>https://binghuacheng.github.io/posts/</link>
    <description>To be a sailor (Posts)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-ch</language>
    <lastBuildDate>Tue, 26 May 2020 11:28:41 +0000</lastBuildDate>
    
    <atom:link href="https://binghuacheng.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>æœŸæœ«æ‚æƒ³</title>
      <link>https://binghuacheng.github.io/posts/%E6%9C%9F%E6%9C%AB%E6%9D%82%E6%83%B3/</link>
      <pubDate>Tue, 26 May 2020 11:28:41 +0000</pubDate>
      
      <guid>https://binghuacheng.github.io/posts/%E6%9C%9F%E6%9C%AB%E6%9D%82%E6%83%B3/</guid>
      <description>&lt;p&gt;äº”æœˆæœ«çš„å—å›½(æµ·å—)å¾ˆæ˜¯ç‚çƒ­ï¼Œå°¤å…¶æ˜¯ä»Šå¹´åœ¨å®Œå…¨æ²¡ç»è¿‡å¤©æ°”çš„è¿‡åº¦çš„æƒ…å†µä¸‹ï¼Œæ¯æ—¥æ¸…æ™¨ä¸€èµ°å‡ºå®¿èˆï¼Œä¾¿ä»¥è‚‰çœ¼å¯è§çš„é€Ÿåº¦æµç€æ±—ï¼Œå¼„å¾—äººæ˜¯å¿ƒçƒ¦æ„ç‡¥ã€‚æ›´è¦å‘½çš„æ˜¯åˆåˆ°äº†æœŸæœ«è€ƒè¯•äº†ï¼Œæ¯å­¦æœŸè¿™æœ€ä»¤äººå¤´ç—›çš„ä¸€ä¸ªæœˆï¼Œæˆ‘å°†ä¸å¾—ä¸å¤ä¹ è¿™æ— èŠçš„ä¸“ä¸šè¯¾ï¼Œä¸€äº›å­¦äº†ä¸¤å¹´äº†ä¾æ—§ä¸çŸ¥é“åˆ°åº•å­¦äº†äº›ä»€ä¹ˆçš„ä¸œè¥¿ã€‚&lt;/p&gt;
&lt;p&gt;åœ¨ä¸€æ‰€ä¸å…¥æµçš„å¤§å­¦ï¼Œè€å¸ˆå’Œæˆ‘ä»¬éƒ½åœ¨æ··æ—¥å­ï¼Œç›¸äº’æ¬ºéª—ï¼Œæ¯•ä¸šåä»–ä»¬ä¾æ—§å¦‚æ­¤ï¼Œè€Œæˆ‘ä»¬æ¯•ä¸šåå³é­é‡ç¤¾ä¼šçš„æ·˜æ±°ï¼Œç„¶åç»ˆèº«æ— æ‰€äº‹äº‹ï¼Œæˆä¸ºæ··è¿¹äºç¤¾ä¼šåº•å±‚çš„åƒåœ¾ã€‚æˆ‘çŸ¥é“æˆ‘ä¸åº”è¯¥è´£æ€ªè€å¸ˆï¼Œè°å«è‡ªå·±å½“å¹´æ— å¿ƒè¯»ä¹¦å‘¢ï¼Œç„¶åå‡­å®åŠ›è€ƒä¸Šè¿™ä¹ˆä¸€æ‰€å……æ»¡å¸Œæœ›çš„å¤§å­¦å‘¢ï¼ç„¶è€Œå”¯ä¸€è®©äººæ— æ³•å¿å—çš„æ˜¯æœ‰çš„è€å¸ˆæ•™ä¹¦çƒ‚ï¼Œå¤‡è¯¾çš„pptéƒ½æ˜¯é”™çš„å°±ç®—äº†ï¼Œè¿˜åè¦ä½ æŒ‰ä»–çš„pptå¤‡è€ƒã€‚è™½ç„¶è¯´è€ƒå®Œå°±å¿˜å®Œ ä½†å†æ€ä¹ˆè¯´ä¹Ÿæœ‰ç‚¹&amp;hellip;&amp;hellip;&lt;/p&gt;
&lt;p&gt;ç„¶è€Œåˆæœ‰ä»€ä¹ˆåŠæ³•å‘¢ï¼Ÿé™¤äº†é¢å¯¹è¿™ä¸€åˆ‡ï¼Œæˆ‘å·²æ— è·¯å¯é€‰ã€‚&lt;/p&gt;
&lt;p&gt;(è²Œä¼¼èƒ½å¤šå†™ä¸€ç‚¹ä¸œè¥¿äº†ğŸ˜‚)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Classes and Dynamic Memory Allocation</title>
      <link>https://binghuacheng.github.io/posts/classes-and-dynamic-memory-allocation/</link>
      <pubDate>Wed, 20 May 2020 11:49:05 +0000</pubDate>
      
      <guid>https://binghuacheng.github.io/posts/classes-and-dynamic-memory-allocation/</guid>
      <description>&lt;h2 id=&#34;main-content&#34;&gt;Main Content&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Using dynamic memory allocation for class members&lt;/li&gt;
&lt;li&gt;Implicit and explicit copy constructor&lt;/li&gt;
&lt;li&gt;What you must do if you use &lt;code&gt;new&lt;/code&gt; in a constructor&lt;/li&gt;
&lt;li&gt;Using &lt;code&gt;static&lt;/code&gt; class methods&lt;/li&gt;
&lt;li&gt;Using placement &lt;code&gt;new&lt;/code&gt; with objects&lt;/li&gt;
&lt;li&gt;Using pointers to objects&lt;/li&gt;
&lt;li&gt;Implementing a queue abstract data type(ADT)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dynamic-memory-and-classes&#34;&gt;Dynamic Memory and Classes&lt;/h2&gt;
&lt;h3 id=&#34;static-class-members&#34;&gt;Static Class Members&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;static class member&lt;/code&gt; has special property: A program create only one copy of a static class variable, regardless of the number of objects created. This is convenient for data that should be private to a class but that should have the same value for all class objects.
&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt; A static data member is declared in the class declaration and is initialized in the file containing the class methods. The scope operator is used in the initialization to indicate to which class the static member belongs. However, if the static member is a &lt;code&gt;const&lt;/code&gt; integral type or an enumeration type, it can be initialized in the class declaration itself.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Warning:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Whenever you use &lt;code&gt;new&lt;/code&gt; in a constructor to allocate memory, you should use &lt;code&gt;delete&lt;/code&gt; in the corresponding destructor to free that memory. If you use &lt;code&gt;new []&lt;/code&gt;(with brackets), then you should use &lt;code&gt;delete []&lt;/code&gt;(with brackets).&lt;/p&gt;
&lt;h3 id=&#34;special-member-functions&#34;&gt;Special Member Functions&lt;/h3&gt;
&lt;p&gt;There are &lt;code&gt;special member function&lt;/code&gt; that are defined automatically. In particular, C++ automatically provides the following member functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A default constructor if you define no constructors.&lt;/li&gt;
&lt;li&gt;A default destructor if you don&amp;rsquo;t define one.&lt;/li&gt;
&lt;li&gt;A copy constructor if you don&amp;rsquo;t define one&lt;/li&gt;
&lt;li&gt;An assignment operator if you don&amp;rsquo;t define one.&lt;/li&gt;
&lt;li&gt;An address operator if you don&amp;rsquo;t define one&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;copy-constructors&#34;&gt;Copy Constructors&lt;/h4&gt;
&lt;p&gt;A copy constructor is used to copy an object to a newly created object. That is, it&amp;rsquo;s used during initialization, including passing function arguments by value and not during ordinary assignment. A copy constructor for a class normally has this prototype:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Class_name(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Class_name &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that it takes a constant reference to a class object as its argument. For example, a copy constructor for the &lt;code&gt;String&lt;/code&gt; class would have this prototype:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;StringBad(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; StringBad &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here are two things to note:&lt;/p&gt;
&lt;h5 id=&#34;when-a-copy-constructor-is-used&#34;&gt;When a copy Constructor is Used&lt;/h5&gt;
&lt;p&gt;A copy constructor is invoked whenever a new object is created and initialized to an existing object of the same kind. This happens in several situations. The most obvious situation is when you explicitly initialize a new object to an existing object. For example, given that &lt;code&gt;motto&lt;/code&gt; is &lt;code&gt;StringBad&lt;/code&gt; object, the following four defining declarations invokes a copy constructor:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;StringBad &lt;span style=&#34;color:#a6e22e&#34;&gt;ditto&lt;/span&gt;(motto);		&lt;span style=&#34;color:#75715e&#34;&gt;// calls StringBad(const StringBad &amp;amp;)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;StringBad metto&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;motto;		&lt;span style=&#34;color:#75715e&#34;&gt;// calls StringBad(const StringBad &amp;amp;)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;StringBad also &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; StringBad(motto);	&lt;span style=&#34;color:#75715e&#34;&gt;// calls StringBad(const StringBad &amp;amp;)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;StringBad &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; pStringBad &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; StringBad(motto);	&lt;span style=&#34;color:#75715e&#34;&gt;// calls StringBad(const StringBad &amp;amp;)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Depending on the implementation, the middle two declarations may use a copy constructor directly to create &lt;code&gt;metoo&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt;, or they may use a copy constructor to generate temporary objects whose contents are then assigned to &lt;code&gt;metto&lt;/code&gt; and &lt;code&gt;also&lt;/code&gt;. The last example initialize an anonymous object to &lt;code&gt;motto&lt;/code&gt; and assigns the address of the new object to the &lt;code&gt;pstringBad&lt;/code&gt; pointer.&lt;/p&gt;
&lt;h5 id=&#34;what-a-default-copy-constructor-does&#34;&gt;What a Default Copy Constructor Does&lt;/h5&gt;
&lt;p&gt;The default copy constructor performs a member-by-member copy of the nonstatic members(memberwise copying, also sometimes called &lt;code&gt;shallow copying&lt;/code&gt;). Each member is copied by value.
If a member is itself a class object, the copy constructor for that class is used to copy one member object to another. Static members, such as &lt;code&gt;num_strings&lt;/code&gt;, are unaffected because they belong to the class as a whole instead of to individual objects.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt; If your class has a static data member whose value changes when new objects are created, you should provide an explicit copy constructor that handles the accounting.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Caution:&lt;/strong&gt;&lt;/em&gt; If a class contains members that are pointers initialized by &lt;code&gt;new&lt;/code&gt;, you should define a copy constructor that copies the pointed-to data instead of copying the pointer themselves. This is termed &lt;code&gt;deep copying&lt;/code&gt;. The alternative form of copying(memberwise, or shallow, &lt;code&gt;copying&lt;/code&gt;) just copies pointer values. A shallow copy is just that &amp;ndash; the shallow &amp;ldquo;scraping off&amp;rdquo; of pointer information for copying, rather than the deeper &amp;ldquo;mining&amp;rdquo; required to copy the constructs referred to by the pointer.&lt;/p&gt;
&lt;h3 id=&#34;assignment-operators&#34;&gt;Assignment Operators&lt;/h3&gt;
&lt;p&gt;C++ allows class object assignment. It does so by automatically overloading an assignment operator for a class. This operator has the following prototype:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Class_name &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; Class_name&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Class_name &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;That is, it takes and returns a reference to an object of the class.&lt;/p&gt;
&lt;h4 id=&#34;when-an-assignment-operator-is-used-and-what-it-does&#34;&gt;When an Assignment Operator is Used and What it Does&lt;/h4&gt;
&lt;p&gt;An overload assignment operator is used when you assign one object to another existing object:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;StringBad &lt;span style=&#34;color:#a6e22e&#34;&gt;headline1&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Celery Stalks at Midnight&amp;#34;&lt;/span&gt;);
...
StringBad knot;
knot&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;headline1;		&lt;span style=&#34;color:#75715e&#34;&gt;// assignment operator invoked
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;An assignment operator is not necessarily used when initializing an object:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;StringBad metoo&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;knot;	&lt;span style=&#34;color:#75715e&#34;&gt;// use copy constructor, possibly assignment, too
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;fixing-assignment&#34;&gt;Fixing Assignment&lt;/h4&gt;
&lt;p&gt;The solution for the problem created by an inappropriate default assignment operator is to provide your own assignment operator definition, one that makes a deep copy. There are some points to note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Because the target object may already refer to previously allocated data, the function should use &lt;code&gt;delete []&lt;/code&gt; to free former obligations.&lt;/li&gt;
&lt;li&gt;The function should protect against assigning an object to itself, otherwise, the freeing of memory described previously could erase the object&amp;rsquo;s contents before they are reassigned.&lt;/li&gt;
&lt;li&gt;The function returns a reference to the invoking object.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here&amp;rsquo;s how you could write an assignment operator for the &lt;code&gt;StringBad&lt;/code&gt; class:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;StringBad &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; StringBad&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; StringBad &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; st)
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;st)	&lt;span style=&#34;color:#75715e&#34;&gt;// object assigned to itself
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt; [] str;		&lt;span style=&#34;color:#75715e&#34;&gt;// free old string
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	len&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;st.len;
	str&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;[len&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];	&lt;span style=&#34;color:#75715e&#34;&gt;// get space for new string
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;strcpy(str, st.str);	&lt;span style=&#34;color:#75715e&#34;&gt;// copy the string
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;;		&lt;span style=&#34;color:#75715e&#34;&gt;// return reference to invoking object
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;the-new-improved-string-class&#34;&gt;The New, Improved &lt;code&gt;String&lt;/code&gt; Class&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;C++11 Null Pointer:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In C++98, the literal &lt;code&gt;0&lt;/code&gt; has two meanings &amp;ndash; it can be the numberic value &lt;code&gt;0&lt;/code&gt;, and it can be the null pointer &amp;ndash; thus making it difficult for the reader and compiler to distinguish between the two. Sometimes programmer use &lt;code&gt;(void *) 0&lt;/code&gt; to identify the pointer version.(The null pointer itself may have a nonzero interal representation.) Other programmers use NULL, a C macro defined to represent the null pointer. However, this proved to be an incomplete solution. C++11 provides a better solution by introducing a new keyword, &lt;code&gt;nullptr&lt;/code&gt;, to denote the null pointer. You still can use &lt;code&gt;0&lt;/code&gt; as before &amp;ndash; otherwise an enormous amount of existing code would be invalidated &amp;ndash; but henceforth the recommendation is to use &lt;code&gt;nullptr&lt;/code&gt; instead:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;str&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;nullptr&lt;/span&gt;;	&lt;span style=&#34;color:#75715e&#34;&gt;// C++11 null pointer notation
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;comparison-members&#34;&gt;Comparison Members&lt;/h3&gt;
&lt;p&gt;The standard &lt;code&gt;strcmp()&lt;/code&gt; function, which returns a negative value if its first argument precedes the second alphabetically, 0 if the strings are the same, and a positive value if the first follows the second alphabetically.&lt;/p&gt;
&lt;h3 id=&#34;static-class-member-function&#34;&gt;Static Class Member Function&lt;/h3&gt;
&lt;p&gt;It&amp;rsquo;s possible to declare a member function as being static. (The keyword &lt;code&gt;static&lt;/code&gt; should appear in the function declaration but not in the function definition if the latter is separate). This has two important consequences.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, a static member function doesn&amp;rsquo;t have to be invoked by an object; in fact, it doesn&amp;rsquo;t even get a &lt;code&gt;this&lt;/code&gt; pointer to play with. If the static member function is declared in the public section, it can be invoked using the class name and the scope-resolution operator.&lt;/li&gt;
&lt;li&gt;The second consequence is that because a static member function is not associated with a particular object, the only data member it can use are the static data members.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;things-to-remember-when-using-new-in-constructors&#34;&gt;Things to Remember When Using &lt;code&gt;new&lt;/code&gt; in Constructors&lt;/h2&gt;
&lt;p&gt;Here are some points that you should notice when using &lt;code&gt;new&lt;/code&gt; to initialize pointer members of an object:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you use &lt;code&gt;new&lt;/code&gt; to initialize a pointer member in a constructor, you should use &lt;code&gt;delete&lt;/code&gt; in the destructor.&lt;/li&gt;
&lt;li&gt;The uses of &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; should be compatible. You should pair &lt;code&gt;new&lt;/code&gt; with &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;new []&lt;/code&gt; with &lt;code&gt;delete []&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If there are multiple constructors, all should use &lt;code&gt;new&lt;/code&gt; the same way &amp;ndash; either all with brackets or all without brackets. There&amp;rsquo;s only one destructor, so all constructors have to be compatible with that destructor. However, it is permissible to initialize a pointer with &lt;code&gt;new&lt;/code&gt; in one constructor and with the null pointer(0, or, with C++11, nullptr) in another constructor because it&amp;rsquo;s okay to apply the &lt;code&gt;delete&lt;/code&gt; operation(with or without brackets) to the null pointer.&lt;/li&gt;
&lt;li&gt;You should define a copy constructor that initialize one object to another by doing deep copying. Typically, the constructor should emulate the following example:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;String(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; String &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; st)
{
	num_strings&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;	&lt;span style=&#34;color:#75715e&#34;&gt;// handle static member update if necessary
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	len&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;st.len;	&lt;span style=&#34;color:#75715e&#34;&gt;// same length as copied string
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	str&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;[len&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];	&lt;span style=&#34;color:#75715e&#34;&gt;// allot space
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;strcpy(str, st.str);	&lt;span style=&#34;color:#75715e&#34;&gt;// copy string to new location
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;You should define an assignment operator that copies one object to another by doing deep copying. Typically, the class method should emulate the following example:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;String &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; String&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; String &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; st)
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;st)	&lt;span style=&#34;color:#75715e&#34;&gt;// object assigned to itself
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;delete&lt;/span&gt; [] str;		&lt;span style=&#34;color:#75715e&#34;&gt;// all done
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	len&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;st.len;		&lt;span style=&#34;color:#75715e&#34;&gt;// free old string
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	len&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;st.len;
	str&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;[len&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];	&lt;span style=&#34;color:#75715e&#34;&gt;// get space for new string
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;strcpy(str, st.str);	&lt;span style=&#34;color:#75715e&#34;&gt;// copy the string
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;;		&lt;span style=&#34;color:#75715e&#34;&gt;// return reference to invoking object
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;membership-initialization&#34;&gt;Membership Initialization&lt;/h2&gt;
&lt;p&gt;C++ Provides a special syntax for class &lt;code&gt;constructors&lt;/code&gt; that can be used to initialize data member. This syntax consists of a colon followed by a comma-separated list of initializers. This is placed after the closing parenthesis of the constructor arguments and before the opening brace of the function body. Each initializer consists of the name of the member being initialized followed by parentheses containing the initialization value. Conceptually, these initializations take place when the object is created and before any statements in the function body are executed. The syntax looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;queue(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; qs) &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; qsize(qs), items(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;), front(NULL), rear(NULL) {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This form is obligatory if the data member is a nonstatic &lt;code&gt;const&lt;/code&gt; member or a reference, except that C++11 in-class initialization can be used for nonstatic &lt;code&gt;const&lt;/code&gt; members.
&lt;em&gt;&lt;strong&gt;Caution:&lt;/strong&gt;&lt;/em&gt; Data member are initialized in the order in which they appear in the class declaration, not in the order in which initializers are listed. You can&amp;rsquo;t use the member initializer list syntax with class methods other than constructors.
C++11 allows in-class initialization(that is, initialization in the class definition):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt;
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
		...
		Node &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; front&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;NULL;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; {Q_SIZE&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;};
		Node &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; rear&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;NULL;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; items&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; qsize&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Q_SIZE;
		...
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is equivalent to using a member initialization list. However, any constructor using a membership initialization list will override the corresponding in-class initializations&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Working With Class</title>
      <link>https://binghuacheng.github.io/posts/working-with-class/</link>
      <pubDate>Tue, 19 May 2020 02:28:26 +0000</pubDate>
      
      <guid>https://binghuacheng.github.io/posts/working-with-class/</guid>
      <description>&lt;h2 id=&#34;main-content&#34;&gt;Main Content&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Operator overloading&lt;/li&gt;
&lt;li&gt;Friend function&lt;/li&gt;
&lt;li&gt;Overloading the &amp;laquo; operator for output&lt;/li&gt;
&lt;li&gt;State members&lt;/li&gt;
&lt;li&gt;Using &lt;code&gt;rand()&lt;/code&gt; to generate random values&lt;/li&gt;
&lt;li&gt;Automatic conversions and type casts for classes&lt;/li&gt;
&lt;li&gt;Class conversion functions&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;operator-overloading&#34;&gt;Operator Overloading&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Operator overloading&lt;/code&gt; is an example of C++ polymorphism. Operator overloading extends the overloading concept to operators, letting you assign multiple meanings to C++ operators.
To overload an operator, you use a special function form called an &lt;code&gt;operator function&lt;/code&gt;. An operator function has the following form, where &lt;code&gt;op&lt;/code&gt; is the symbol for the operator being overloaded:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;operatorop(argument&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;list)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For example, &lt;code&gt;operator+()&lt;/code&gt; overloads the &lt;code&gt;+&lt;/code&gt; operator and &lt;code&gt;opeartor*()&lt;/code&gt; overloads the &lt;code&gt;*&lt;/code&gt; operator. The &lt;code&gt;op&lt;/code&gt; has to be a valid C++ operator; you can&amp;rsquo;t just make up a new symbol.&lt;/p&gt;
&lt;p&gt;Suppose, for example, that you have a &lt;code&gt;Salesperson&lt;/code&gt; class for which you define an &lt;code&gt;operator+()&lt;/code&gt; member function to overload the &lt;code&gt;+&lt;/code&gt; operator so that it adds sales figures of one salesperson object to another. Then, if &lt;code&gt;district2&lt;/code&gt;, &lt;code&gt;sid&lt;/code&gt;, and &lt;code&gt;sare&lt;/code&gt; are all object of the &lt;code&gt;salesperson&lt;/code&gt; class, you can write this equation:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;district2&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sid&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;sare;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The compiler, recognizing the operands as belonging to the &lt;code&gt;salesperson&lt;/code&gt; class, replaces the operator with the corresponding operator function:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;district2&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sid.&lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;(sara);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;developing-an-operator-overloading-example&#34;&gt;Developing an Operator Overloading Example&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Caution:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Don&amp;rsquo;t return a reference to a local variable or another temporary object. When the function terminates and the local variable or temporary object disappears, the reference becomes a reference to non-exist data.&lt;/p&gt;
&lt;h3 id=&#34;overloading-restrictions&#34;&gt;Overloading Restrictions&lt;/h3&gt;
&lt;p&gt;Overloaded operators(with some exceptions) don&amp;rsquo;t necessarily have to be member functions. However, there are some limits C++ imposes on user-defined operator overloading:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The overloaded operator must have at least one operand that is user-defined type.&lt;/li&gt;
&lt;li&gt;You can&amp;rsquo;t use an operator in a manner that violates the syntax rules for the original operator. For example, you can&amp;rsquo;t overload the modules operator(%) so that it can be used with a single operand. Similarly, you can&amp;rsquo;t alter operator precedence. So if you overload the addition operator to let you add two classes, the new operator has the same precedence as ordinary addition.&lt;/li&gt;
&lt;li&gt;You can&amp;rsquo;t create new operator symbols. For example, you can&amp;rsquo;t define an &lt;code&gt;operator**()&lt;/code&gt; function to denote exponentiation.&lt;/li&gt;
&lt;li&gt;You cannot overload the following operators:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;|Operator	|Description			|
|.....		|.......			|
|sizeof		|the sizeof operator		|
|.		|the membership operator	|
|.*		|the pointer-to-member operator	|
|::		|the scope-resolution operator	|
|?:		|the conditional operator	|
|typeid		|An RTTI operator		|
|const_cast	|A type cast operator		|
|dynamic_cast	|A type cast operator		|
|reinterpret	|A type cast operator		|
|static_cast	|A type cast operator		|
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Most of the operators in Table11.1 can be overloaded by using either member or nonmemberfunctions. However, you can use &lt;code&gt;only&lt;/code&gt; member function to overload the following operators:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;|Operator		|Description				|
|........		|........				|
|	=		|Assignment operator			|
|	()		|Function call operator			|
|	[]		|Subscripting operator			|
|	-&amp;gt;		|Class member access by pointer operator|
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Table 11.1&lt;/strong&gt;&lt;/em&gt; Operator that can be overloaded&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+	-	*
/	%	&amp;amp;
|	~	!
=	&amp;lt;	&amp;gt;
+=	-=	*=
/=	%=	&amp;amp;=
|=	&amp;lt;&amp;lt;	&amp;gt;&amp;gt;
&amp;gt;&amp;gt;=	&amp;lt;&amp;lt;=	==
!=	&amp;lt;=	&amp;gt;=
&amp;amp;&amp;amp;	||	++
--	,	-&amp;gt;*
-&amp;gt;	()	[]	
new	delete	
new[]	delete[]
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;introducing-friends&#34;&gt;Introducing Friends&lt;/h2&gt;
&lt;p&gt;C++ provides another form of access the private portion of a class object: the &lt;code&gt;friend&lt;/code&gt;. Friend comes in three varieties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Friend functions&lt;/li&gt;
&lt;li&gt;Friend classes&lt;/li&gt;
&lt;li&gt;Friend member functions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With the nonmember overloaded operator function, the left operand of an operator expression corresponds to the first argument of the operator function, and the right operand corresponds to the second argument. Using a nonmember function(&lt;code&gt;friend function&lt;/code&gt;) solves the problem of getting the operands in the desired order.&lt;/p&gt;
&lt;h3 id=&#34;creating-friends&#34;&gt;creating Friends&lt;/h3&gt;
&lt;p&gt;The first step toward creating a friend function is to place a prototype in the class declaration and prefix the declaration with the keyword &lt;code&gt;friend&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;friend&lt;/span&gt; Time &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; m, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Time &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; t);	&lt;span style=&#34;color:#75715e&#34;&gt;// goes into class declaration
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This prototype has two implications:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Althrough the operator*() function is declared in the class declaration, it is not a member function. So it isn&amp;rsquo;t invoked by using the membership operator.&lt;/li&gt;
&lt;li&gt;Althrough the operator*() function isn&amp;rsquo;t a member function, it has the same access rights as a member function.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The second step is to write the function definition. Because it is not a member function, you don&amp;rsquo;t use the &lt;code&gt;Time::&lt;/code&gt; qualifier. Also you don&amp;rsquo;t use the &lt;code&gt;friend&lt;/code&gt; keyword in the definition. For instance:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Time &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; m, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Time &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; t)	&lt;span style=&#34;color:#75715e&#34;&gt;//friend not used in definition
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;a-common-kind-of-friend-overloading-the--operator&#34;&gt;A Common Kind of Friend: Overloading the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; Operator&lt;/h3&gt;
&lt;p&gt;One of the most common tasks for operator overloading is defining the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator so that it can be used in conjunction with the &lt;code&gt;cout&lt;/code&gt; object to display an object&amp;rsquo;s contents.
In general, to overload the &amp;laquo; operator to display an object of class &lt;code&gt;c_name&lt;/code&gt;, you use a friend function with a definition in this form:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;ostream &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;(ostream &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; os, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; c_name &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; obj)
{
	os &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; ...;	&lt;span style=&#34;color:#75715e&#34;&gt;// display object content
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; os;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;multiple-representation-and-classes&#34;&gt;Multiple Representation and Classes&lt;/h3&gt;
&lt;p&gt;Quantities that have different, but equivalent, representations are common.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First, you can store multiple representations in one object.&lt;/li&gt;
&lt;li&gt;Second, you can write the class function so that assigning values for one representation automatically assigns values for the other representation(s).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;overloading-arithmetic-operators&#34;&gt;Overloading Arithmetic Operators&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Tip:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If a method needs to compute a new class object, you should see if you can use a class constructor to do the work. Not only does that save you trouble, it ensures that the new object is constructed in the proper fashion.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt;
Because operator overloading is implemented with functions, you can overload the same operator many times, as long as each operator function has a distinct signature and as long as each operator function has the same number of operands as the corresponding built-in C++ operator.&lt;/p&gt;
&lt;h2 id=&#34;automatic-conversiona-and-type-casts-for-classes&#34;&gt;Automatic Conversiona and Type Casts for Classes&lt;/h2&gt;
&lt;p&gt;You may define a class suffciently related to a basic type or another class that it makes sense to convert from one form to another. In such a case, you can tell C++ how to make such conversions automatically.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt; A C++ constructor that contains one argument defines a type conversion from the argument type to the class type. If the constructor is qualified with the keyword &lt;code&gt;explicit&lt;/code&gt;, the constructor is used for explicit conversion only; otherwise, it is also used for implicit conversation.&lt;/p&gt;
&lt;p&gt;When does the compiler use the &lt;code&gt;Stonewt(double)&lt;/code&gt; function? If the keyword &lt;code&gt;explicit&lt;/code&gt; is used in the declaration, &lt;code&gt;Stonewt(double)&lt;/code&gt; is used only for an explicit type cast; otherwise, it is also used for the following implicit conversions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When you initialize a &lt;code&gt;Stonewt&lt;/code&gt; object to a type &lt;code&gt;double&lt;/code&gt; value.&lt;/li&gt;
&lt;li&gt;When you assign a type &lt;code&gt;double&lt;/code&gt; value to a &lt;code&gt;Stonewt&lt;/code&gt; object&lt;/li&gt;
&lt;li&gt;Whe you pass a type &lt;code&gt;double&lt;/code&gt; value to a function that expects a &lt;code&gt;Stonewt&lt;/code&gt; argument.&lt;/li&gt;
&lt;li&gt;When a function that&amp;rsquo;s declared to return a &lt;code&gt;Stonewt&lt;/code&gt; value tries to return a &lt;code&gt;double&lt;/code&gt; value.&lt;/li&gt;
&lt;li&gt;When any of the preceding situations use a built-in type that can unambiguously be converted to type &lt;code&gt;double&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt; Note that when a constructor has a single argument, you can use the following form when initializing a class object:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// a syntax for initializing a class object when
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// using a constructor with one argument
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Stonewt incognito&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;275&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is equivalent to the other two forms shown earlier:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// standard syntax forms for initializing class objects
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Stonewt &lt;span style=&#34;color:#a6e22e&#34;&gt;incognito&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;275&lt;/span&gt;);
Stonewt incognito&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Stonewt(&lt;span style=&#34;color:#ae81ff&#34;&gt;275&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;However, the last forms can also be used with constructors that have multiple arguments.&lt;/p&gt;
&lt;h3 id=&#34;conversion-function&#34;&gt;Conversion Function&lt;/h3&gt;
&lt;p&gt;Constructors only provide for converting another type to the class type. To do the reverse, you have to use a special form of C++ operator function called a &lt;code&gt;conversion function&lt;/code&gt;.
So how do you create a conversion function? To convert to type &lt;code&gt;typename&lt;/code&gt;, you use a conversion function in this form:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt;()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note the following points:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The conversion function must be a class method.&lt;/li&gt;
&lt;li&gt;The conversion function must not specify a return type&lt;/li&gt;
&lt;li&gt;The conversion function must have no arguments.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, a function to convert to type double would have this prototype:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Caution:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;You should use implicit conversion functions with care. Often a function that can only be invoked explicitly is the best choice. A conversion function must be a member function.&lt;/p&gt;
&lt;p&gt;C++ provides the following type conversions for classes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A class constructor that has but a single argument serves as an instruction for converting a value of the argument type to the class type.&lt;/li&gt;
&lt;li&gt;A special class member operator function called &lt;code&gt;conversion function&lt;/code&gt; serves as an instruction for converting a class object to some other type.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;about-returning-objects&#34;&gt;About Returning Objects&lt;/h2&gt;
&lt;h3 id=&#34;returning-reference-to-a-const-object&#34;&gt;Returning Reference to a &lt;code&gt;const&lt;/code&gt; Object&lt;/h3&gt;
&lt;p&gt;The usual reason for using a &lt;code&gt;const reference&lt;/code&gt; is efficiency, but there are restrictions on when this choice can be used. If a function returns an object that is passed to it, either by object invocation or as a method argument, you can increase the effiency of the method by having it return a reference.&lt;/p&gt;
&lt;h3 id=&#34;returning-a-reference-to-a-non-const-object&#34;&gt;Returning a Reference to a &lt;code&gt;Non-const&lt;/code&gt; Object&lt;/h3&gt;
&lt;p&gt;Two common example of returning a non-const object are overloading the assignment operator and overloading the &amp;laquo; operator for use with cout. The first is done for reasons of effiency, and the second for reasons of necessity.&lt;/p&gt;
&lt;h3 id=&#34;returning-an-object&#34;&gt;Returning an Object&lt;/h3&gt;
&lt;p&gt;If the object being returned is local to the called function, then it should not be returned by reference because the local object has its destructor called when the function terminated. Thus, when control returns to the calling function, there is no object left to which the reference can refer. In these circumstances, you should return an object, not a reference. Typically, overloaded arithmetic operator fall into this category.&lt;/p&gt;
&lt;h3 id=&#34;returning-a-const-object&#34;&gt;Returning a &lt;code&gt;const&lt;/code&gt; Object&lt;/h3&gt;
&lt;h2 id=&#34;using-pointers-to-objects&#34;&gt;Using Pointers to Objects&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Object Initialization with new:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In general, if &lt;code&gt;Class_name&lt;/code&gt; is a class and if &lt;code&gt;value&lt;/code&gt; is of type &lt;code&gt;Type name&lt;/code&gt;, the statement&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Class_name &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; pclass &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Class_name(value);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;invokes this constructor:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Class_name(Type_name);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;there may be trivial conversion, such as to this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Class_name(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Type_name &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Also the usual conversions incoked by prototype matching, such as from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;double&lt;/code&gt;, takes place as long as there is no ambiguity. An initialization in the following form invokes the default constructor:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Class_name &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; ptr&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; class_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Objects and Classes</title>
      <link>https://binghuacheng.github.io/posts/objects-and-classes/</link>
      <pubDate>Sun, 17 May 2020 09:10:31 +0000</pubDate>
      
      <guid>https://binghuacheng.github.io/posts/objects-and-classes/</guid>
      <description>&lt;h2 id=&#34;main-content&#34;&gt;Main Content&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;procedural and object-oriented programming&lt;/li&gt;
&lt;li&gt;The concept of classes&lt;/li&gt;
&lt;li&gt;How to define and implement a class&lt;/li&gt;
&lt;li&gt;Public and private class&lt;/li&gt;
&lt;li&gt;Class data members&lt;/li&gt;
&lt;li&gt;Class methods(also called class function members)&lt;/li&gt;
&lt;li&gt;Creating and using class objects&lt;/li&gt;
&lt;li&gt;Class constructors and destructors&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt; member function&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;this&lt;/code&gt; pointer&lt;/li&gt;
&lt;li&gt;Creating array of objects&lt;/li&gt;
&lt;li&gt;Class scope&lt;/li&gt;
&lt;li&gt;Abstract data types&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;procedural-and-object-oriented-programming&#34;&gt;Procedural and Object-Oriented Programming&lt;/h2&gt;
&lt;p&gt;In short, with an OOP approach, you concentrate on the object as the user perceives it, thinking about the data you need to describe the object and and the operations that will describe the user&amp;rsquo;s interaction with the data. After you develop a description of that interface, you move on to decide how to implement the interface and data storage. Finally, you put together a program to use your new design.&lt;/p&gt;
&lt;h2 id=&#34;abstraction-and-classes&#34;&gt;Abstraction and Classes&lt;/h2&gt;
&lt;h3 id=&#34;type&#34;&gt;Type&lt;/h3&gt;
&lt;p&gt;In short, specifying a basic type does three things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It determines how much memory is needed for a data object.&lt;/li&gt;
&lt;li&gt;It determines how the bits in memory are interpreted.(A &lt;code&gt;long&lt;/code&gt; and &lt;code&gt;float&lt;/code&gt; might use the same number of bits in memory, but they are translated into numberic values differently.)&lt;/li&gt;
&lt;li&gt;It determines what operators, or methods, can be performed using the data object&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;classes-in-c&#34;&gt;Classes in C++&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;class&lt;/code&gt; is a C++ vehicle for translating an abstraction to a user-defined type. It combines data representation and methods for manipulating that data into one neat package.
Generally , a class specifier has two parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;code&gt;class declaration&lt;/code&gt;, which describes the data component, in terms of member functions and the public interface, in terms of member function, termed &lt;code&gt;methods&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;class method definition&lt;/code&gt;, which describes how certain class member function are implemented.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Roughly speaking, the class declaration provides a class overview, whereas the method definitions supply the details
Typically, C++ programmers place the interface, in the form of a class definition, in the header and places the implementation, in the form of code for the class methods, in a source code file.
The binding of data and methods into a single unit is the most striking feature of the class.&lt;/p&gt;
&lt;h4 id=&#34;access-control&#34;&gt;Access Control&lt;/h4&gt;
&lt;p&gt;The keyword &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;public&lt;/code&gt; describe &lt;code&gt;access control&lt;/code&gt; for class members. Any program that uses an object of a particular class can access the public portions directly. A program can access the private members of a object by using the public member function or a friend function.
The public member functions act as go-betweens between a program and an object&amp;rsquo;s private members; they provide the interface between object and program. The insulation(n.ç»ç¼˜ï¼Œéš”ç¦») of data from direct access by a program is called &lt;code&gt;data hiding&lt;/code&gt;.
The public interface represents the abstraction component of the design. Gathering the implementation details together and separating from the abstraction is called &lt;code&gt;encapsulation&lt;/code&gt;. &lt;code&gt;Data hiding&lt;/code&gt;(putting data into the private section of a class) is an instance of encapsulation, another example of encapsulation is the usual practice of placing class function in a separate file from the class declaration.&lt;/p&gt;
&lt;h4 id=&#34;member-access-control-public-or-private&#34;&gt;Member Access Control: Public or Private?&lt;/h4&gt;
&lt;p&gt;Because the main percepts of OOP is to hide the data, data items normally go into the private section. The member functions that consitute the class interface go into the public section.
You don&amp;rsquo;t have to use the keyword &lt;code&gt;private&lt;/code&gt; in class declarations because this is the default access control for class objects:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;World&lt;/span&gt;
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; mass;	&lt;span style=&#34;color:#75715e&#34;&gt;// private by default
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; name[&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;];	&lt;span style=&#34;color:#75715e&#34;&gt;// private by default
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; tellall(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;);
	...
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;implementing-class-member-functions&#34;&gt;Implementing class Member Functions&lt;/h3&gt;
&lt;p&gt;The class member function has two special characteristics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When you define a member function, you use the scope-resolution operator(::) to identify the class to which the function belongs.&lt;/li&gt;
&lt;li&gt;Class methods can access the &lt;code&gt;private&lt;/code&gt; components of the class&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;inline-methods&#34;&gt;Inline Methods&lt;/h4&gt;
&lt;p&gt;Any function with a definition in the class declaration automatically becomes an inline function.&lt;/p&gt;
&lt;h4 id=&#34;which-objects-does-a-method-use&#34;&gt;Which Objects Does a method Use?&lt;/h4&gt;
&lt;p&gt;When you call a member function, it uses the data members of the particular object used to invoke the member function.
Each new object you create contains storage for its own internal variables, the class members. But all objects of the same class share the same set of class methods, with just one copy of each method. Suppose, for example, that &lt;code&gt;kate&lt;/code&gt; and &lt;code&gt;joe&lt;/code&gt; are &lt;code&gt;Stock&lt;/code&gt; objects. In that case, &lt;code&gt;kate.shares&lt;/code&gt; occupies one chunk of memory, and &lt;code&gt;joe.show()&lt;/code&gt; occupies a second chunk of memory. But &lt;code&gt;kate.show&lt;/code&gt; and &lt;code&gt;joe.show&lt;/code&gt; both invoke the same method.
Calling a member function is what some OOP language term &lt;code&gt;sending a message&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;using-classes&#34;&gt;Using Classes&lt;/h3&gt;
&lt;p&gt;***Note:***The Client/Server Model&lt;/p&gt;
&lt;p&gt;OOP programmers often discuss program design in terms of a client/server model. In this conceptualization, the &lt;code&gt;client&lt;/code&gt; is a program that uses the class. The class declaration, including the methods, constitute the server, which is a resource that is available to the programmer that need it. The client uses the server throuht the publicly defined interface only. This means that the client&amp;rsquo;s only reposbility, and, by extension, the client&amp;rsquo;s programmer&amp;rsquo;s only reponsibility, is to know that interface. The server&amp;rsquo;s reponsibility, and by extension, the server&amp;rsquo;s designer&amp;rsquo;s reponsibility, is to see that the server reliably and accurately performs according to that interface. Any changes the server designer makes to the class design should be to details of implementation, not to the interface. This allows programmers to improve the client and client independently of each other, without changes in the server having unforseen repercussion on client&amp;rsquo;s behavior.&lt;/p&gt;
&lt;h2 id=&#34;class-constructorsinitialize-class-object--and-destructors&#34;&gt;Class Constructors(&lt;code&gt;initialize class object&lt;/code&gt;)  and Destructors&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt; Although the constructor has no return value, it&amp;rsquo;s not declared type &lt;code&gt;void&lt;/code&gt;. In fact, a constructor has no declared type.&lt;/p&gt;
&lt;h3 id=&#34;declaring-and-defining-constructors&#34;&gt;Declaring and Defining Constructors&lt;/h3&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// constructor prototype with some default arguments
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Stock(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; co, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; pr&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;)

...

&lt;span style=&#34;color:#75715e&#34;&gt;// constructor definition
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Stock&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Stock(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; co, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; n, &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; pr)
{
	company &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; co;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (n&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
	{	
		std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cerr &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Number of shares can&amp;#39;t be negative; &amp;#34;&lt;/span&gt;
			&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; company &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; shares set to 0.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
		shares&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
		shares&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;n;
	share_val&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;pr;
	set_tot();

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Member Names and Parameter Names:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Often those new to constructors try to use the class names as parameter names in the constructors, as in this example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Stock&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Stock(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; company, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; shares, &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; share_val)
{
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is wrong. The constructor arguments don&amp;rsquo;t represent the class members; they represent values that are assigned to the class member. Thus, they must have distanct names, or you end up with confusing code like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;shares&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;shares;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;One common coding practice to avoid such confusion is to use an &lt;code&gt;m_&lt;/code&gt; prefix to identify data member names:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Stock&lt;/span&gt;
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
		string m_company;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; m_shares;
		...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Another common practice is to use an underbar suffix for member names:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Stock&lt;/span&gt;
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
		string company_;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; shares_;
	...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;using-constructors&#34;&gt;Using Constructors&lt;/h3&gt;
&lt;p&gt;C++ provides two ways to initialize an object by using a constructor. The first is to call the constructor explicitly:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Stock food &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Stock(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;World Cabbage&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;250&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.25&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The second way is to call the constructor implicitly:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Stock &lt;span style=&#34;color:#a6e22e&#34;&gt;garment&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Furry Mason&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2.5&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The more compact form is equivalent to the following explicit call:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Stock garment&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Stock(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Furry Mason&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2.5&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;C++ uses a class constructor whenever you create an object of that class, even when you use &lt;code&gt;new&lt;/code&gt; for dynamic memory allocation. Here&amp;rsquo;s how to use the constructor with &lt;code&gt;new&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Stock &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pstock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Stock(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Electroshock Games&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;18&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;19.0&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this case, the object doesn&amp;rsquo;t have a name, but you can use the pointer to manage the object.
&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt; You can&amp;rsquo;t use an object to invoke a constructor.&lt;/p&gt;
&lt;h3 id=&#34;default-constructors&#34;&gt;Default Constructors&lt;/h3&gt;
&lt;p&gt;A &lt;code&gt;default constructor&lt;/code&gt; is a constructor that is used to create an object when you don&amp;rsquo;t provide explicit initialization values. That is, it&amp;rsquo;s a constructor used for declarations like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Stock fluffy_the_cat;	&lt;span style=&#34;color:#75715e&#34;&gt;// uses the default constructor
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can define a default constructor two ways. One is to provide default values for all the arguments to the existing constructor:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Stock(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; co &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Error&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; pr&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The second is to use function overloading to define a second constructor, one that has no arguments:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Stock();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can have only one default constructor, so be sure that you don&amp;rsquo;t do both.
When you design a class, you should usually provide a default constructor that implicitly initialize all class members.
After you&amp;rsquo;ve used either method(no arguments or default values for all arguments) to create the default constructor, you can declare object variable without initializing them explicitly:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Stock first;	&lt;span style=&#34;color:#75715e&#34;&gt;// calls default constructor implicitly
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Stock first&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Stock();	&lt;span style=&#34;color:#75715e&#34;&gt;// call default constructor explicitly
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Stock &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;prelief &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Stock;	&lt;span style=&#34;color:#75715e&#34;&gt;// calls default constructor implicitly
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;However, you shouldn&amp;rsquo;t be misled by the implicit form of the nondefault constructor:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Stock &lt;span style=&#34;color:#a6e22e&#34;&gt;first&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Concrete Conglomerate&amp;#34;&lt;/span&gt;);	&lt;span style=&#34;color:#75715e&#34;&gt;// calls nondefault constructor
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Stock &lt;span style=&#34;color:#a6e22e&#34;&gt;second&lt;/span&gt;()		&lt;span style=&#34;color:#75715e&#34;&gt;// declare a function that returns a ```Stock``` object
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Stock third;		&lt;span style=&#34;color:#75715e&#34;&gt;// calls default constructor
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When you implicitly call the default constructor, you don&amp;rsquo;t use parentheses.&lt;/p&gt;
&lt;h3 id=&#34;destructors&#34;&gt;Destructors&lt;/h3&gt;
&lt;p&gt;Like a constructor, a destructor has a special name: it is formed from the class name preceded by a tilde(~). Thus, the destructor for the &lt;code&gt;Stock&lt;/code&gt; class is called &lt;code&gt;~Stock()&lt;/code&gt;. Also like a constructor, a destructor can have no return value and has no declared type. But, unlike a constructor, a destructor must have no arguments. Thus, the prototype for a &lt;code&gt;Stock&lt;/code&gt; destructor must be this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;Stock()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you create a static storage class object, its destructor is called automatically when the program terminates. If you create an automatic storage class object, its destructor is called automatically when the program exits the block of code in which the object is defined. If the object is created by &lt;code&gt;new&lt;/code&gt;, it resides in heap memory, or the free store, and its destructor is called automatically when you use &lt;code&gt;delete&lt;/code&gt; to free the memory.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;When you assign one object to another of the same class, by default C++ copies the contents of each data member of the source object to the corresponding data member of the target object.
Here are two ways to create objects:
&lt;em&gt;&lt;strong&gt;Tip:&lt;/strong&gt;&lt;/em&gt; If you can set object either through initialization or by assignment, choose initialization. It is usually more efficient.&lt;/p&gt;
&lt;h4 id=&#34;const-member-functions&#34;&gt;&lt;code&gt;const&lt;/code&gt; Member Functions&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;show&lt;/span&gt;() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;;	&lt;span style=&#34;color:#75715e&#34;&gt;// promises not to change invoking object
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Similarly, the beginning of the function definition should look like this:
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; stock&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;show() &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// promises not to change invoking object
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Class functions declared and definited this way are called &lt;code&gt;const&lt;/code&gt; member function. Just as you should use &lt;code&gt;const&lt;/code&gt; reference and pointers as formal function argument whenever appropriate, you should make class methods &lt;code&gt;const&lt;/code&gt; whenever they don&amp;rsquo;t modify the invoking object.&lt;/p&gt;
&lt;h4 id=&#34;c11-list-initialization&#34;&gt;C++11 List Initialization&lt;/h4&gt;
&lt;p&gt;Suppose the &lt;code&gt;Bazo&lt;/code&gt; class has the following prototype for a class constructor:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Bozo(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; fname, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; lname);	&lt;span style=&#34;color:#75715e&#34;&gt;// constructor prototype
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Before C++11, you can use it to initialize new objects as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Bazo bozetta&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Bozo(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Bozetta&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Biggers&amp;#34;&lt;/span&gt;);	&lt;span style=&#34;color:#75715e&#34;&gt;// primary form
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Bozo &lt;span style=&#34;color:#a6e22e&#34;&gt;fufu&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Fufu&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;O&amp;#39;Dweep&amp;#34;&lt;/span&gt;);		&lt;span style=&#34;color:#75715e&#34;&gt;// short form
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Bozo &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Bozo(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Popo&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Le Peu&amp;#34;&lt;/span&gt;);	&lt;span style=&#34;color:#75715e&#34;&gt;// dynamic object
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In C++11, you can use the list initialization instead:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Bozo bozetta&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Bozetta&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Biggens&amp;#34;&lt;/span&gt;};	&lt;span style=&#34;color:#75715e&#34;&gt;// C++11
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Bozo fufu{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Fufu&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;O&amp;#39;Dweeb&amp;#34;&lt;/span&gt;};		&lt;span style=&#34;color:#75715e&#34;&gt;//C++11
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Bozo &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Bozo{&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Popo&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Le Peu&amp;#34;&lt;/span&gt;;};	&lt;span style=&#34;color:#75715e&#34;&gt;//C++11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;knowing-your-objects-the-this-pointer&#34;&gt;Knowing your Objects: The &lt;code&gt;this&lt;/code&gt; pointer&lt;/h2&gt;
&lt;p&gt;Suppose, then, that you want to compare the &lt;code&gt;Stock&lt;/code&gt; objects &lt;code&gt;stock1&lt;/code&gt; and &lt;code&gt;stock2&lt;/code&gt; and assign the one with the greater value to the object &lt;code&gt;top&lt;/code&gt;. You can use either of the following statement to do so:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;top&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;stock1.topval(stock2);
top&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;stock2.topval(stock1);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The first form access &lt;code&gt;stock1&lt;/code&gt; implicitly and &lt;code&gt;stock2&lt;/code&gt; explicitly, whereas the second access &lt;code&gt;stock1&lt;/code&gt; explicitly and &lt;code&gt;stock&lt;/code&gt; implicitly.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;this&lt;/code&gt; pointer points to the object used to invoke a member function.(Basically, &lt;code&gt;this&lt;/code&gt; is passed as a hidden argument to the method.) Thus, the function call &lt;code&gt;stock1.topval(stock2)&lt;/code&gt; sets &lt;code&gt;this&lt;/code&gt; to the address of the &lt;code&gt;stock1&lt;/code&gt; object.
&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt; Each member function, including constructors and destructors, has a &lt;code&gt;this&lt;/code&gt; pointer. The special property of the &lt;code&gt;this&lt;/code&gt; pointer is that it points to the invoking object. If a method needs to refer to the invoking object as a whole, it can use the expression &lt;code&gt;*this&lt;/code&gt;. Using the const qualifier after the function argument parentheses qualifies  &lt;code&gt;this&lt;/code&gt; as being a pointer to &lt;code&gt;const&lt;/code&gt;; in that case, you can&amp;rsquo;t use &lt;code&gt;this&lt;/code&gt; to change the object&amp;rsquo;s value.&lt;/p&gt;
&lt;h2 id=&#34;class-scope&#34;&gt;Class Scope&lt;/h2&gt;
&lt;p&gt;Class scope applies to names defined in a class, such as the names of class data member and class member functions. Items that have class scope are known within the class but not outside the class. Thus, you can use the same member names in different classes without conflict.&lt;/p&gt;
&lt;h3 id=&#34;class-scope-constants&#34;&gt;Class Scope Constants&lt;/h3&gt;
&lt;p&gt;First, you can declare an enumeration within a class. An enumeration given in a class declaration has class scope, so you can use enumeration to provide class scope symbolic name for integer constants. That is, you can start off the &lt;code&gt;Bakery&lt;/code&gt; declaration this way:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Bakery&lt;/span&gt;
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; { Months&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt; };
		&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; costs[Months];
	...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Because the &lt;code&gt;Bakery&lt;/code&gt; class uses the enumeration merely to create a symbolic constant, with no intent of creating variables of the enumeration type, you needn&amp;rsquo;t provide an enumeration tag.
C++ has a second way of defining a constant within a class &amp;ndash; using the keyword &lt;code&gt;static&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Bakery&lt;/span&gt;
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;private&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Months&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; costs[Months];
		...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This creates a single constant called &lt;code&gt;Months&lt;/code&gt; that is stored with other static variables rather than in an object. Thus, there is only one &lt;code&gt;Month&lt;/code&gt; constant shared by all &lt;code&gt;Bakery&lt;/code&gt; objects.&lt;/p&gt;
&lt;h3 id=&#34;scoped-enumerationsc11&#34;&gt;Scoped Enumerations(C++11)&lt;/h3&gt;
&lt;p&gt;Regular enumberations get converted to integer types automatically in some situations, such as assignment to an &lt;code&gt;int&lt;/code&gt; variable or being used in comparison expression, but scoped enumerations have no implicit conversions to integer types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;egg_old&lt;/span&gt; {Small, Medium, Large, Jumbo};	&lt;span style=&#34;color:#75715e&#34;&gt;// unscoped
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;t_shirt&lt;/span&gt; {Small, Medium, Large, Xlarge};	&lt;span style=&#34;color:#75715e&#34;&gt;// scoped
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;egg_old one&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Medium;	&lt;span style=&#34;color:#75715e&#34;&gt;// unscoped 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;t_shirt rolf&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;t_shirt&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Large;	&lt;span style=&#34;color:#75715e&#34;&gt;// scoped
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; king&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;one;	&lt;span style=&#34;color:#75715e&#34;&gt;// implicit type conversion for unscoped
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ring&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;rolf;	&lt;span style=&#34;color:#75715e&#34;&gt;// not allowed, no implicit type conversation
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (king&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Jumbo)		&lt;span style=&#34;color:#75715e&#34;&gt;// allowed
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Jumbo converted to int before comparision.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (king&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;t_shirt&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Medium)	&lt;span style=&#34;color:#75715e&#34;&gt;// not allowed
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Not allowed: &amp;lt; not defined for scoped enum.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Enumberations are represented by some underlying integer type, and under C98 that choice was implementation-dependent.
By default, the underlying type for C++11 scoped enumberations is &lt;code&gt;int&lt;/code&gt;. However, there&amp;rsquo;s a syntax for indicating a different choice:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// underlying type for pizza is short
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;: &lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;short&lt;/span&gt; pizza{Small, Medium, Large, XLarge};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;: short&lt;/code&gt; specifies the underlying type to be &lt;code&gt;short&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;OOP emphasizes how a program represents data. The first step toward solving a programming problem by using the OOP approach is to describe the data in terms of its interface with the program, specifying how the data is used. Next, you need to design a class that implements the interface. Typically, private data members storage the informaion, whereas public member functions, also called methods, provide the only access to the data. The class combines data and methods into one unit, and the private aspect accomplish data hiding.
Usually, you separate a class declaration into two parts, usually kept in separate files. The class declaration proper goes into a header file, with the methods represented by function prototype. The source code that defines the member functions goes into a method file. This approach separates the description of the interface from the details of the implementation. In principle, you need to know only the public class interface to use the class.
A class is a user-defined type, and an object is an instance of a class. This means an object is a variable of that type or the equivalent of a variable, such as memory allocated by &lt;code&gt;new&lt;/code&gt; according to the class specification. C++ tries to make user-defined types as similarly as possible to standard types, so you can declare objects, pointers to objects, and array of objects. You can pass objects as arguments, return them as function return values, and assign one object to another of the same type. If you provide a constructor method, you can initialize objects when they are created. If you provide a destructor method, the program execute that method when the object expires.
Each object holds its own copies of the data portion of a class declaration, but they share the class methods. If &lt;code&gt;my_object&lt;/code&gt; is the name of a particular object and &lt;code&gt;try_me()&lt;/code&gt; is a member function, you invoke the member function by using the dot membership operator:&lt;code&gt;mr_object.try_me()&lt;/code&gt;. OOP terminology describes this function call as sending a &lt;code&gt;try_me()&lt;/code&gt; message to the &lt;code&gt;mr_object&lt;/code&gt; object. Any reference to class data member in the &lt;code&gt;try_me()&lt;/code&gt; method then applies to the data members of the &lt;code&gt;mr_object&lt;/code&gt; object. Similarly, the function call &lt;code&gt;i_object,try_me()&lt;/code&gt; access the data member of the &lt;code&gt;i_object&lt;/code&gt; object.
If you want a member function to act on more than one object, you can pass additional objects to the method as arguments. If a method needs to refer explicitly to the object that evoked it, it can use the &lt;code&gt;this&lt;/code&gt; pointer. The &lt;code&gt;this&lt;/code&gt; pointer is set to the address of the evoking object, so &lt;code&gt;*this&lt;/code&gt; is an alias for object itself.
Classes are well matched to describing ADTs. The public member function interface provides the service described by an ADT, and the class&amp;rsquo;s private section and the code for the class methods provide an implementation that is hidden from clients of the class.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Thinking0</title>
      <link>https://binghuacheng.github.io/posts/thinking0/</link>
      <pubDate>Sat, 16 May 2020 14:29:27 +0000</pubDate>
      
      <guid>https://binghuacheng.github.io/posts/thinking0/</guid>
      <description>&lt;p&gt;When you trust science completely, that&amp;rsquo;s not science, that&amp;rsquo;s religion.&lt;/p&gt;
&lt;p&gt;There are no perfect thing, so sometimes you must abandon the trivial things and pick up the most important and meaningful things.&lt;/p&gt;
&lt;p&gt;When you try to find the most perfect things, you can&amp;rsquo;t succeed, most time in life, you have to accept the errors.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Memory Modules and Namespaces</title>
      <link>https://binghuacheng.github.io/posts/memory-modules-and-namespaces/</link>
      <pubDate>Sat, 16 May 2020 05:50:08 +0000</pubDate>
      
      <guid>https://binghuacheng.github.io/posts/memory-modules-and-namespaces/</guid>
      <description>&lt;h2 id=&#34;main-content&#34;&gt;Main Content&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Separate compilation of programs&lt;/li&gt;
&lt;li&gt;Storage duration, scope, and linkage&lt;/li&gt;
&lt;li&gt;Placement &lt;code&gt;new&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Namespaces&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;separate-compilation&#34;&gt;Separate Compilation&lt;/h2&gt;
&lt;p&gt;In general, We divide the program into three parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A header file that contains the structure declarations and prototypes for functions that use those structures&lt;/li&gt;
&lt;li&gt;A source code file that contains the code for the structure-related functions&lt;/li&gt;
&lt;li&gt;A source code file that contains the code that calls the structure-related functions&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here are some things commonly found in header files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function prototypes&lt;/li&gt;
&lt;li&gt;Symbolic constants defined using &lt;code&gt;#define&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Structure declarations&lt;/li&gt;
&lt;li&gt;Class declarations&lt;/li&gt;
&lt;li&gt;Template declarations&lt;/li&gt;
&lt;li&gt;Inline function&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;storage-duration-scope-and-linkage&#34;&gt;Storage Duration, Scope, and Linkage&lt;/h2&gt;
&lt;p&gt;C++ uses four separate schemes for sorting data, and the scheme differ in how long they preserve data in memory:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Automatic storage duration&lt;/li&gt;
&lt;li&gt;Static storage duration&lt;/li&gt;
&lt;li&gt;Thread storage duration(C++11)&lt;/li&gt;
&lt;li&gt;Dynamic storage duration&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;specifiers-and-qualifiers&#34;&gt;Specifiers and Qualifiers&lt;/h3&gt;
&lt;p&gt;Certain C++ keywords, called &lt;code&gt;storage class specifier&lt;/code&gt; and &lt;code&gt;cv-qualifiers&lt;/code&gt;, provided  additional information about storage.&lt;/p&gt;
&lt;h4 id=&#34;cv-qualifiers&#34;&gt;Cv-Qualifiers&lt;/h4&gt;
&lt;p&gt;Here are the cv-qualifiers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;const&lt;/li&gt;
&lt;li&gt;volatile&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;code&gt;volatile&lt;/code&gt; keyword indicates that the value in a memory location can be altered even though nothing in the program code modifies the contents. The intent of this keyword is to improve the optimization abilities of compiler. For example, suppose the compiler notices that a program uses the value of a particular variable twice within a few statementss. Rather than have the program look up the value twice, the compiler might cache the value in a register. This optimization assumes that the value of the variable doesn&amp;rsquo;t change between the two uses. If you don&amp;rsquo;t define a variable as &lt;code&gt;volatile&lt;/code&gt;, then the compiler can feel free to make this optimization. If you do declare a variable as &lt;code&gt;volatile&lt;/code&gt;, you&amp;rsquo;re telling the compiler not to make that sort of optimization.&lt;/p&gt;
&lt;h4 id=&#34;mutable&#34;&gt;mutable&lt;/h4&gt;
&lt;p&gt;You can use it to indicate that a particular member of a structure(or class) can be altered even if a particular structure(or class) variable is a &lt;code&gt;const&lt;/code&gt;. For example,&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; name[&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;];
	&lt;span style=&#34;color:#66d9ef&#34;&gt;mutable&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; accesses;
	...
};
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; data veep &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Claybourne Clodde&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, ...};
strcpy(veep.name, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Joye Joux&amp;#34;&lt;/span&gt;);
veep.accesses&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;about-const&#34;&gt;About &lt;code&gt;const&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;In c++(but not C), the &lt;code&gt;const&lt;/code&gt; modifier alters the default storage classes slightly. Whereas a global variable has external linkage by default, a &lt;code&gt;const&lt;/code&gt; global variable has internal linkage by default.
If, for some reason, you want to make a constant have external linkage, you can use the &lt;code&gt;external&lt;/code&gt; keyword to override the default internal linkage:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;external &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; states&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;;	&lt;span style=&#34;color:#75715e&#34;&gt;// definition with external linkage
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When you declare a &lt;code&gt;const&lt;/code&gt; within a function or block, it has block scope, which means the constant is usable only when the program is executing code within the block. This means that you can create constant within a function or block and not have to worry about the names conflicting with constants defined elsewhere.&lt;/p&gt;
&lt;h3 id=&#34;function-and-linkageone-definition-rule&#34;&gt;Function and Linkage(One definition rule)&lt;/h3&gt;
&lt;p&gt;C++, like C, doesn&amp;rsquo;t allow you to define one function inside another, so all function automatically have static storage duration, meaning they are all present as long as the program is running. By default, functions have external linkage, meaning they can be shared across files. You can, in fact, use the keyword &lt;code&gt;extern&lt;/code&gt; in a function prototype to indicate that the function is defined in another file, but that&amp;rsquo;s optional. You can also use the keyword &lt;code&gt;static&lt;/code&gt; to give a function internal linkage, confining its use to a single file. You would apply this keyword to the &lt;code&gt;prototype&lt;/code&gt; and the &lt;code&gt;function definition&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; where C++ find functions&lt;/p&gt;
&lt;p&gt;Suppose you call a function in a particular program. Where does C++ look for the function definition? If the function prototype in that file indicates that the file is static, the compiler looks only in that file for the function definition. Otherwise, the compiler(and the linker, too) look in all the program files. If it finds two definition, the compiler sends you a error message because you can have only one definition for one external function. If it fails to find any definition in the files, the function then searches the libraries. This implies that if you define a function that has the same name as a library function, the compiler uses you version rather than the library version.(However, C++ reserves the names of the standard library functions, so you shound&amp;rsquo;t reuse them.) Some compiler-linker need explicit instructions to identify which library to search.&lt;/p&gt;
&lt;h2 id=&#34;storages-schemes-and-dynamic-allocation&#34;&gt;Storages Schemes and Dynamic Allocation&lt;/h2&gt;
&lt;p&gt;The dynamic memory can be allocated from one function and freed from another function. Unlike automatic memory, dynamic memory is not &lt;code&gt;LIFO&lt;/code&gt;; the order of allocation and freeing depends on when and how &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; are used.&lt;/p&gt;
&lt;h3 id=&#34;new-operators-functions-and-replacement-function&#34;&gt;&lt;code&gt;new&lt;/code&gt;: Operators, Functions, and Replacement Function&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;new[]&lt;/code&gt; operators call upon two functions:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;new&lt;/span&gt;(std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;size_t);	&lt;span style=&#34;color:#75715e&#34;&gt;//used by new
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;[](std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;size_t);	&lt;span style=&#34;color:#75715e&#34;&gt;//used by new[]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;These are termed &lt;code&gt;allocation function&lt;/code&gt;, and they are part of the global namespace. Similarly, there are deallocation functions used by &lt;code&gt;delete&lt;/code&gt; and &lt;code&gt;delete[]&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;delete&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;);		&lt;span style=&#34;color:#75715e&#34;&gt;// used by new
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;operator&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;[](std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;size_t);	&lt;span style=&#34;color:#75715e&#34;&gt;// used by new[]
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here the &lt;code&gt;std::size_t&lt;/code&gt; is &lt;code&gt;typedef&lt;/code&gt; for some suitable integer type.
A basic statement such as&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; pi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;gets translated into something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; pi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And the statement&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; pa &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;gets translated into something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; pa&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In general, using the &lt;code&gt;new&lt;/code&gt; operator may do more than just call the &lt;code&gt;new()&lt;/code&gt; function.&lt;/p&gt;
&lt;h3 id=&#34;the-placement-new-operator&#34;&gt;The Placement &lt;code&gt;new&lt;/code&gt; Operator&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;new&lt;/code&gt; operator has a variation, called &lt;code&gt;placement new&lt;/code&gt;, that allows you to specify the location to be used. You can use thid feature to set up your own memory-management procedures or to deal with hardware that is accessed via a particular address or to construct objects in a particular memory location.
To use the placement &lt;code&gt;new&lt;/code&gt; feature, you first include the &lt;code&gt;new&lt;/code&gt; header file, which provides a prototype for this version of &lt;code&gt;new&lt;/code&gt;. The following code fragment shows the syntax for using these four forms of &lt;code&gt;new&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;new&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chaff&lt;/span&gt;
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; dross[&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;];
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; slag;
};
&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buffer1[&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; buffer2[&lt;span style=&#34;color:#ae81ff&#34;&gt;500&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()
{
	chaff &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p1, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p2;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p3, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p4;
	&lt;span style=&#34;color:#75715e&#34;&gt;// first, the regular forms of new
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	p1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; chaff;	&lt;span style=&#34;color:#75715e&#34;&gt;// place structure in heap
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	p3&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;];	&lt;span style=&#34;color:#75715e&#34;&gt;// place int array in heap
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// now, thw two forms of placement new
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	p2&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; (buffer1) chaff;	&lt;span style=&#34;color:#75715e&#34;&gt;// place structure in buffer1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	p4&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; (buffer2) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;];	&lt;span style=&#34;color:#75715e&#34;&gt;//place int array in buffer2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;other-forms-of-placement-new&#34;&gt;Other Forms of Placement &lt;code&gt;new&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Just as regular ``new&lt;code&gt;invokes a new function with one argument, the standard placement&lt;/code&gt;new``` invokes a new function with two arguments:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;;	&lt;span style=&#34;color:#75715e&#34;&gt;// invokes new(sizeof(int))
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; (buffer) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;;	&lt;span style=&#34;color:#75715e&#34;&gt;// invokes new(sizeof(int), buffer)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; p3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; (buffer) &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;];	&lt;span style=&#34;color:#75715e&#34;&gt;// invokes new(40*sizeof(int), buffer)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;namespaces&#34;&gt;Namespaces&lt;/h2&gt;
&lt;h3 id=&#34;traditional-c-namespaces&#34;&gt;Traditional C++ Namespaces&lt;/h3&gt;
&lt;p&gt;One term you need to be aware of is &lt;code&gt;declarative region&lt;/code&gt;. A declaratice region is a region in which declaration can be made. For example, you can declare a global variable outside any function. The declarative region for that variable is the file in which it is declared. If you declare a variable inside a function , its declarative region is the innermost block in which it is declared.
A second term you need to be aware of is &lt;code&gt;potential scope&lt;/code&gt;. The potential scope for a variable begins at its point of declaration and extends to the end of its declarative region.
The portion of the program that can actually see the the variable is termed the &lt;code&gt;scope&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;new-namespace-features&#34;&gt;New Namespace Features&lt;/h3&gt;
&lt;p&gt;The following code, for example, uses the keyword &lt;code&gt;namespace&lt;/code&gt; to craete two namespaces, &lt;code&gt;Jack&lt;/code&gt; and &lt;code&gt;Jill&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; Jack {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; pail;	&lt;span style=&#34;color:#75715e&#34;&gt;// variable declaration
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetch&lt;/span&gt;();	&lt;span style=&#34;color:#75715e&#34;&gt;// function prototype
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; pal;	&lt;span style=&#34;color:#75715e&#34;&gt;// variable declaration
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Well&lt;/span&gt; {...};	&lt;span style=&#34;color:#75715e&#34;&gt;// structe declaration
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}

&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; Jill {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bucket&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; n) {...}	&lt;span style=&#34;color:#75715e&#34;&gt;//function definition
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; fetch;		&lt;span style=&#34;color:#75715e&#34;&gt;// variable declaration
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; pal;	&lt;span style=&#34;color:#75715e&#34;&gt;// variable declaration
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Hill&lt;/span&gt; {...};	&lt;span style=&#34;color:#75715e&#34;&gt;// structure declaration
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Namespaces can be located at the global level or inside other namespace, but they cannot be placed in a block. Thus, a name declared in a namespace has external linkage by default(unless it refers to a &lt;code&gt;constant&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Namepsace are &lt;code&gt;open&lt;/code&gt;, meaning that they can add names to existing namespaces. for example, the following statement adds the name &lt;code&gt;goose&lt;/code&gt; to the existing list of names in &lt;code&gt;Jill&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; Jill {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;goose&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Of course, you need a way to access names in a given namespace. The simplest way is to use ::, the scope-resolution operator, to &lt;code&gt;qualify&lt;/code&gt;(é™å®šï¼Œä¿®é¥°ï¼‰ a name with its namespace:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;Jack&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;pail&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;12.34&lt;/span&gt;;	&lt;span style=&#34;color:#75715e&#34;&gt;// use a variable
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Jill&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Hill&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;mole; 	&lt;span style=&#34;color:#75715e&#34;&gt;// create a type Hill structure
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Jack&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;fetch();		&lt;span style=&#34;color:#75715e&#34;&gt;//use a function
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;An unadorned name, such as &lt;code&gt;pail&lt;/code&gt;, is termed the &lt;code&gt;unqualified name&lt;/code&gt;, whereas a name with the namespace, as in &lt;code&gt;Jack::pail&lt;/code&gt;, is termed a &lt;code&gt;qualified name&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;using-declarations-and-using-directives&#34;&gt;&lt;code&gt;using&lt;/code&gt; Declarations and &lt;code&gt;using&lt;/code&gt; Directives&lt;/h3&gt;
&lt;p&gt;C++ provides two mechanisms &amp;ndash; the &lt;code&gt;using declaration&lt;/code&gt; and the &lt;code&gt;using directive&lt;/code&gt; &amp;ndash; to simplify using namespace names. The &lt;code&gt;using&lt;/code&gt; declaration lets you make particular identifier available, and the &lt;code&gt;using directive&lt;/code&gt; makes the entire namespace accessible. for instance:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Jill&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;fetch&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;;	&lt;span style=&#34;color:#75715e&#34;&gt;// a using declaration
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;using-directives-versus-using-declarations&#34;&gt;&lt;code&gt;using&lt;/code&gt; Directives Versus &lt;code&gt;using&lt;/code&gt; Declarations&lt;/h3&gt;
&lt;p&gt;If a particular name is alreday declared in a function, you can&amp;rsquo;t import the same name with a &lt;code&gt;using declaration&lt;/code&gt;. However, if you use a &lt;code&gt;using  directiv&lt;/code&gt;e to import a name that is already declared in a function, the local name will hide the namespace name, just as it would hide a global variable of the same name. But you can still use the scope-resolution operators, as in the following example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; Jill {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bucket&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; n) { }
	&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; fetch;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Hill&lt;/span&gt; { ... };
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; fetch;	&lt;span style=&#34;color:#75715e&#34;&gt;// global namespace
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; Jill;	&lt;span style=&#34;color:#75715e&#34;&gt;// import all namespace names
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	Hill Thrill;		&lt;span style=&#34;color:#75715e&#34;&gt;// create a type Jill::Hill structure
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; water&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;bucket(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;);	&lt;span style=&#34;color:#75715e&#34;&gt;// use Jill::bucket();
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; fetch;		&lt;span style=&#34;color:#75715e&#34;&gt;// not an error; hides Jill::fetch
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; fetch;		&lt;span style=&#34;color:#75715e&#34;&gt;// read a value into the local fetch
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;fetch;		&lt;span style=&#34;color:#75715e&#34;&gt;// read a value into global fetch
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	cin &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; Jill&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;fetch;	&lt;span style=&#34;color:#75715e&#34;&gt;// read a value into Jill::fetch
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	...
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foom&lt;/span&gt;()
{
	Hill top;	&lt;span style=&#34;color:#75715e&#34;&gt;// ERROR
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	Jill&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;Hill crest;	&lt;span style=&#34;color:#75715e&#34;&gt;// valid
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Generally speaking, the &lt;code&gt;using&lt;/code&gt; declaration is safer to use than a &lt;code&gt;using&lt;/code&gt; directive because it shows exactly what names you are making available . And if the name conflict with a local name, the compiler lets you know. The &lt;code&gt;using&lt;/code&gt; directive adds all names, even one you might not need. If a local name conflicts, it overrides the namespace version, and you aren&amp;rsquo;t warned. Also, the open nature of namespaces means that the complete list of names in a namespace might be spread over several locations, making it difficult to know exactly which name you are adding.&lt;/p&gt;
&lt;h3 id=&#34;more-namespace-feature&#34;&gt;More Namespace Feature&lt;/h3&gt;
&lt;p&gt;You can nest namespace declarations, like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; elements
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; fire
	{
		&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; flame;
		...
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; water;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this case, you can refer to the flame variable as elements::fire::flame. Similarly, you can make the inner names available with this &lt;code&gt;using&lt;/code&gt; directive:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; element&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;fire;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Also, you can use &lt;code&gt;using&lt;/code&gt; directive and &lt;code&gt;using&lt;/code&gt; declarations inside namespaces, like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; myth
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; Jill&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;fetch;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; elements;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cout;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; std&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;cin;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now consider applying a &lt;code&gt;using&lt;/code&gt; directive to the &lt;code&gt;myth&lt;/code&gt; namespace. The &lt;code&gt;using&lt;/code&gt; directive is &lt;code&gt;transtive&lt;/code&gt;. In this context, the upshot is that the following statement places both the &lt;code&gt;myth&lt;/code&gt; and &lt;code&gt;elements&lt;/code&gt; namespaces in scope:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; myth;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This single directive has the same effect as the following two directives:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; myth;
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; elements;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can create an alias for a namespace. For example, suppose you have a namespace defined as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; my_very_favorite_things { ... };
&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; mvft&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;my_very_favorite_things;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can use this technique to simplify using nested namespaces:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; MEF&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;myth&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;element&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;fire;
&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; MEF&lt;span style=&#34;color:#f92672&#34;&gt;::&lt;/span&gt;flame;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;unnamed-namespaces&#34;&gt;Unnamed Namespaces&lt;/h3&gt;
&lt;p&gt;You can create an &lt;code&gt;unnamed namespace&lt;/code&gt; by omiting the namespace name:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// unnamed namespace
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; ice;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; bandcoot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Names in an unnamed namespace are like global variables. This provides an alternative to using static variables with internal linkage.&lt;/p&gt;
&lt;h3 id=&#34;namespaces-and-the-future&#34;&gt;Namespaces and the Future&lt;/h3&gt;
&lt;p&gt;Here are some programming idioms:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use variables in a named namespace instead of using external global variables.&lt;/li&gt;
&lt;li&gt;Use variable in an unnamed namespace instead of using static global variable.&lt;/li&gt;
&lt;li&gt;If you develop a library of functions or classes, place them in a namespace. Instead, C++ currently already calls for placing standard library function in a namespace called &lt;code&gt;std&lt;/code&gt;. This extends to functions brought in from C. For example, the &lt;code&gt;math.c&lt;/code&gt; header file, which is C-compatible, doesn&amp;rsquo;t use namespaces, but the C++ &lt;code&gt;cmath&lt;/code&gt; header file should place the various math library functions in the &lt;code&gt;std&lt;/code&gt; namespace.&lt;/li&gt;
&lt;li&gt;Use the &lt;code&gt;using&lt;/code&gt; directive only as a tempolary means of converting old code to namespace usage.&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t use &lt;code&gt;using&lt;/code&gt; directives in header files; for one thing, doing so conceals which names are being made available. Also, the ordering of header files may affect behavior. If you use a &lt;code&gt;using&lt;/code&gt; directive, place it after all the preprocessor &lt;code&gt;#include&lt;/code&gt; directive.&lt;/li&gt;
&lt;li&gt;Preferentially import names by using the scope-resolution operator or a &lt;code&gt;using&lt;/code&gt; declaration.&lt;/li&gt;
&lt;li&gt;Preferentially use local scope instead of global scope for &lt;code&gt;using&lt;/code&gt; declarations.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;C++ encourages the use of multiple files in developing programs. An effective organization strategy is to use a header file to define user types and provide function prototype for functions to manipulate the user type. You should use a separate source code file for the fnction definitions. Together, the header file and the source file define and implement the user-defined type and how it can be used. Then, &lt;code&gt;main()&lt;/code&gt; and other functions using those functions can go into a third file.
C++&#39;s storage schemes determine how long variables remain in memory(storage duration) and what parts of a program have access to them(scope and linkage). Automatic variables are variables that are defined within a block, such as a function body or a block within the body. They exist and are known only while the program executes statements in the block that contains the definition. Automatic variable may be declared by using the storage class specifier &lt;code&gt;register&lt;/code&gt; or with no specifier at all, in which case the variable is automatically automatic. The &lt;code&gt;register&lt;/code&gt; specifier was a hint to the compiler that the variable is heavily used, but that use is deprecated(åå¯¹) under C++11.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Adventures in Functions</title>
      <link>https://binghuacheng.github.io/posts/adventures-in-functions/</link>
      <pubDate>Tue, 12 May 2020 04:53:49 +0000</pubDate>
      
      <guid>https://binghuacheng.github.io/posts/adventures-in-functions/</guid>
      <description>&lt;h2 id=&#34;c-inline-functions&#34;&gt;C++ Inline Functions&lt;/h2&gt;
&lt;p&gt;In an inline functionï¼Œthe compiled code is &amp;ldquo;in line&amp;rdquo; with the the other code in the program. With inline codeï¼Œthe program doesn&amp;rsquo;t have to jump to another location to execute the code and jump back. Inline function thus run a little faster than regular functionï¼Œ but they come with a memory penaltyï¼ˆn.æƒ©ç½šï¼‰. If a program calls an inline function at ten separate locationsï¼Œthen the program winds up with ten copies of the function inserted into the code.&lt;/p&gt;
&lt;p&gt;To use the Inline functionï¼Œyou must take at least one of two actions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Preface the functio &lt;code&gt;declaration&lt;/code&gt; with the keyword &lt;code&gt;inline&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Preface the function &lt;code&gt;definition&lt;/code&gt; with the keyword &lt;code&gt;inline&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A common practice is to omit the prototype and to place the entire definition where the prototype would normally go.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If the function is too larger or calls itselfï¼Œ don&amp;rsquo;t use inline function.&lt;/p&gt;
&lt;h2 id=&#34;reference-variables&#34;&gt;Reference Variables&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;reference&lt;/em&gt; is a name that acts as an aliasï¼Œor an alternative nameï¼Œfor a &lt;strong&gt;previously defined&lt;/strong&gt; variable.&lt;/p&gt;
&lt;p&gt;The main use for a reference variable is as a formal argument to a function. If you use a reference as a argumentï¼Œthe function works with the original data instead of with a copy.&lt;/p&gt;
&lt;h3 id=&#34;creating-a-reference-variable&#34;&gt;Creating a Reference Variable&lt;/h3&gt;
&lt;p&gt;C and C++ use the &amp;amp; symbol to indicate the address of a variableï¼Œhowever C++ assigns an additional meaning to the &amp;amp; symbol and presses it into service for declaring references. For exampleï¼Œto make &lt;em&gt;rodents&lt;/em&gt; an alternative name for variable &lt;em&gt;rats&lt;/em&gt;ï¼Œyou could do the following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; rats;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; rodents &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rats &lt;span style=&#34;color:#75715e&#34;&gt;// makes rodents an alias for rats 
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Just as char * in a declaration means pointer-to-charï¼Œint &amp;amp; means reference-to-int. The reference declaration allows you to use &lt;em&gt;rats&lt;/em&gt; and &lt;em&gt;rodents&lt;/em&gt; interchangeably; both refer to the same value and the same momory location.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt; You should initialize a reference variable when you declare it.&lt;/p&gt;
&lt;p&gt;A reference is rather like a &lt;strong&gt;const&lt;/strong&gt; pointer; you have to initialize it when you create itï¼Œand when a reference pledges(v. ä¿è¯ï¼Œè®¸è¯ºï¼‰its allegiance to a particular variableï¼Œit stick to its pledge. That isï¼Œ
int &amp;amp; rodents=rats;
isï¼Œin essenceï¼Œa disguised notation for something like this:
int * const pr=&amp;amp;rats;
Hereï¼Œthe reference &lt;em&gt;rodents&lt;/em&gt; play the same role as the express *pr.&lt;/p&gt;
&lt;p&gt;Suppose you tried the following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; rats&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;101&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; pt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;rats;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;rodents &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; bunnies &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;;
pt &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;bunnies;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Initializing rodents to *pt makes rodents refer to rats. Subsequently altering pt to point to bunnies does not alter the fact that rodents refers to rats.&lt;/p&gt;
&lt;h3 id=&#34;references-as-function-parameters&#34;&gt;References as Function Parameters&lt;/h3&gt;
&lt;p&gt;Most oftenï¼Œreferences are used as function parameters, making a variable in a function an alias for a variable in the calling program. This method of passing arguments is called &lt;em&gt;&lt;strong&gt;passing by reference&lt;/strong&gt;&lt;/em&gt;. Passing by reference allows a called function to access variable in the calling function. For instance:
swapr.cpp&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;swapr&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; b);

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;using&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;namespace&lt;/span&gt; std;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; wallet1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt;;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; wallet2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;350&lt;/span&gt;;
	cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wallet1 = $&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; wallet1;
	cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wallet2 = $&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; wallet2; 
		&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;
	cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Using references to swap contents:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
	swapr(wallet1&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;ï¼Œ&lt;/span&gt;wallet2);
	cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wallet1 = $&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; wallet1;
	cout &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;wallet2 = $&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; wallet2 &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; endl;

	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;swapr&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; a, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; b)
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; temp;

	temp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a;
	a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;b;
	b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;temp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt; A function call initializes its parameters with argument values from the function call. So reference function arguments are initialized to the argument passed by the function call.&lt;/p&gt;
&lt;h3 id=&#34;reference-properties-and-oddities&#34;&gt;Reference Properties and Oddities&lt;/h3&gt;
&lt;p&gt;If your intent is that a function use the information passed to it without modifying the information, and if you&amp;rsquo;re using a reference, you should use aa constant reference. Here, for example, you should use &lt;em&gt;const&lt;/em&gt; in the function prototype and function header:
double cube(const double &amp;amp;r)&lt;/p&gt;
&lt;h4 id=&#34;temporary-variables-references-arguments-and-const&#34;&gt;Temporary Variables, References Arguments, and &lt;em&gt;const&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;C++ can generate a tempolary variable if the actual argument doesn&amp;rsquo;t match a reference argument. Currently, C++ permits this only if the argument is a const reference.&lt;/p&gt;
&lt;p&gt;Provided that the reference parameter is a &lt;em&gt;const&lt;/em&gt;, the compiler generates a temporary variable in two kinds of situations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When the actual argument is the correct type but isn&amp;rsquo;t an lvalue&lt;/li&gt;
&lt;li&gt;When the actual argument is of the wrong type, but it&amp;rsquo;s of a type that can be converted to the correct type.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Both a regular variable abd a const variable would be considered lvalues because both can accessed by address. But the regular variable can be further characterized as being a &lt;em&gt;modifiable lvalue&lt;/em&gt; and the const variable as a &lt;em&gt;non-modifiable lvalue&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;If the intent of a function with argument is to modify variables passed as arggument, situation that create temporary variables thwart that purpose. The solution is to prohibit creating temporary variables in these situation.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If a function call argument isn&amp;rsquo;t an &lt;em&gt;lvalue&lt;/em&gt; or doesn&amp;rsquo;t match the type of the corresponding &lt;em&gt;const&lt;/em&gt; reference parameter, C++ creates an anonymous variable of the correct type, assigns the value of the function call argument to the annoymous variable, and has the parameter refer to that variable.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Use const when you can&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;There are three strong reason to declare reference arguments as references to the constant data:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Using &lt;strong&gt;const&lt;/strong&gt; protects you against programming errors that  inadvertently alter data.&lt;/li&gt;
&lt;li&gt;Using &lt;strong&gt;const&lt;/strong&gt; allows a function to process both &lt;strong&gt;const&lt;/strong&gt; and &lt;strong&gt;non-const&lt;/strong&gt; actual argguments, whereas a function that omits &lt;strong&gt;const&lt;/strong&gt; in the prototype only can accept non-const data.&lt;/li&gt;
&lt;li&gt;Using a const reference allows the function to generate and use a temporary variable appropriately.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++11 introduces a second kind of reference, called an &lt;strong&gt;rvalue reference&lt;/strong&gt;, that can reference to an rvalue.&lt;/p&gt;
&lt;h3 id=&#34;using-references-with-a-structure&#34;&gt;Using References with a Structure&lt;/h3&gt;
&lt;p&gt;References work wonderfully with structures and classes, C++&#39;s user-defined types. Indeed, references were introduced primarily for use with these types, not for use with the basic built-in types.&lt;/p&gt;
&lt;h4 id=&#34;why-return-a--reference&#34;&gt;Why Return a  Reference?&lt;/h4&gt;
&lt;p&gt;Now consider this statement:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; dup=accumulate(team, five);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;a-function-that-returns-a-reference-is-actually-an-alias-for-the-referred-to-variable&#34;&gt;If accumulate() returned a structure instead of a reference to a structure, this could involve copying the entire structure to a temporary location  and then copying that copy to dup. But with a reference return value, team is copied directly to dup, a  more efficient approach.
&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt;
&lt;code&gt;A function that returns a reference is actually an alias for the referred-to variable.&lt;/code&gt;&lt;/h2&gt;
&lt;h4 id=&#34;being-careful-about-what-a-return-reference-refers-to&#34;&gt;Being Careful About What a Return Reference Refers To&lt;/h4&gt;
&lt;p&gt;The single most important point to remember when returning a reference is to  avoid returning a reference to a memory location that ceases to exist when the function terminates. What you want to avoide is code along these lines:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; free_throws &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; clone2(free_throws &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; ft)
{
	free_throws newguy;
	newguy&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;ft;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; newguy;
}
This has the unfortunate effect of returning a reference to a temporary variable(newguy) that passes from existence as soon as the function terminates. Similarly, you should avoid returning pointers to such temporary variables.
&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; The simple way to avoid this problem is to &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; a reference that was passed as an argument to the function. A reference parameter will refer to data used by the calling function; hence, the returned reference will refer to the same data.
&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; A second method is to use new to create new storage.
&lt;span style=&#34;color:#f92672&#34;&gt;---&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#### Why Use const with a Reference Return?
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Suppose you want to use a reference &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; value but don&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt;t want to permit such as assigning a value to accumulate(). Just make the &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; type a &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; reference:
&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;```&lt;/span&gt;c&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; free_throws &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;
	accumulate(free_throws &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; target, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; free_throws &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; source);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The return type now is const, hence a nonmodifiable lvalue. Therefore, the assignment no longer is allowed:
accumulate(dup, five)=four; // not allowed for const reference return&lt;/p&gt;
&lt;h3 id=&#34;using-references-with-a-class-object&#34;&gt;Using References with a class Object&lt;/h3&gt;
&lt;p&gt;The usual C++ practice for passing class objects to a function is to use references. For instance, you would use reference parrameters for functions taking objects of the &lt;em&gt;&lt;strong&gt;string, ostream, istream, ofstream&lt;/strong&gt;&lt;/em&gt;, and &lt;em&gt;&lt;strong&gt;ifstream&lt;/strong&gt;&lt;/em&gt; classes as arguments.&lt;/p&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;string &lt;span style=&#34;color:#a6e22e&#34;&gt;version1&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; s1, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; string &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; s2)
{
	string temp;
	temp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;s2&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;s1&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;s2;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; temp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;the-temp-object-is-a-new-object-local-to-the-version1-function-and-it-ceases-to-exist-when-the-function-terminates-thus-returning-temp-as-a-reference-wont-work-so-the-function-type-is-string&#34;&gt;The &lt;em&gt;&lt;strong&gt;temp&lt;/strong&gt;&lt;/em&gt; object is a new object, local to the version1() function, and it ceases to exist when the function terminates. Thus, returning temp as a reference won&amp;rsquo;t work, so the function type is string.&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Passing a C-style String Argument to a string Object Reference Parameter:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;You may have noticed a rather interesting fact about the version1() function: Both formal parameters(s1 and s2) are type &lt;em&gt;&lt;strong&gt;const string &amp;amp;&lt;/strong&gt;&lt;/em&gt;, but the actual arguments(input and &amp;ldquo;***&amp;quot;) are type string and const char *, respectively. Because input is type string, there is no problem having s1 refer to it. But how is it that the program accepts passing a pointer-to-char argument to a string reference?
Two things are going on here. One is that the string class defines a char *-to-string conversion, which makes it possible to initialize a string object to a C-style string. The second is a property of const reference formal parameters that is discussed earlier in this charpter. Suppose the actual argument type doesn&amp;rsquo;t match the reference parameter type but can be converted to the reference type. Then the program creates a temporay variable of the correct type, initialize it to the converted value, and passes a reference to the temporary variable. Earlier this character you saw, for instance, that a const douuble &amp;amp; parameter can handle an int arggument in this fashion. Similarly, a const string &amp;amp; pparameter can handle a char * or const char * argument in this fashion.
The convenient outcome of this is that if the formal parameter is type const string &amp;amp;, the actual argument used in the function call can be a string object or a C-style string, such as a quoted string literal, a null-terminated array of char, or a pointer variable that points to a char.&lt;/p&gt;
&lt;h3 id=&#34;another-object-lesson-objects-inheritance-and-references&#34;&gt;Another Object Lesson: Objects, Inheritance, and References&lt;/h3&gt;
&lt;p&gt;A derived class inherits the base class methods, which means that an &lt;em&gt;&lt;strong&gt;ofstream&lt;/strong&gt;&lt;/em&gt;  object can use base class features such as the precision() and setf() formatting methods.
Another aspect of inheritance is that a base reference can refer to a derived class object without requiring a type cast.&lt;/p&gt;
&lt;h3 id=&#34;when-to-use-reference-arguments&#34;&gt;When to Use Reference Arguments&lt;/h3&gt;
&lt;p&gt;There are two main reasons for using reference arguments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;To allow you to alter a data object in the calling function&lt;/li&gt;
&lt;li&gt;To speed up a program by passing a reference instead of an entire data object.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are some guidelines about when you should use a reference, a pointer and pass by value:
1.A function uses passed data without modifying it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the data object is small, such as a built-in data type or a small structure, pass it by value.&lt;/li&gt;
&lt;li&gt;If the data object is a good-sized structure, use a const pointer or a const reference to increase program effiency. You save the time and space needed to copy a structure or a class design. Make the pointer or reference const.&lt;/li&gt;
&lt;li&gt;If the data object is an array, use a pointer because that&amp;rsquo;s your only choice. Make the pointer a pointer to const.&lt;/li&gt;
&lt;li&gt;If the data object is a class object, use a const reference. The semantics of class design often require using a reference, which is the main reason C++ added this feature. Thus, the standard way to pass class object arguments is by reference.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.A function modifies data in the calling function:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the data object is built-in data type, use a pointer. If you spot code like fixit(&amp;amp;x), where x is an int, it&amp;rsquo;s very pretty clear that this function intends to modify x.&lt;/li&gt;
&lt;li&gt;If the datya object is an array, use your only choice: a poiter.&lt;/li&gt;
&lt;li&gt;If the data object is a structure, use a reference or a pointer.&lt;/li&gt;
&lt;li&gt;If the data object is a class object, use a reference.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;default-arguments&#34;&gt;Default Arguments&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;default argument&lt;/em&gt; is a value that&amp;rsquo;s used automatically if you omit the corresponding actual argument from a function call.
When you use a function with an argument list, you must add defaults from right to left. That is, you can&amp;rsquo;t provide a default value for a particular argument unless you also provide defaults for the arguments to its right:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;harpo&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);	&lt;span style=&#34;color:#75715e&#34;&gt;// valid
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;chico&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j);	&lt;span style=&#34;color:#75715e&#34;&gt;// invalid
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;groucho&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; k&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; m&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);	&lt;span style=&#34;color:#75715e&#34;&gt;// valid
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that only the prototype indicates the default. The function definition is the same as it would be without default arguments.&lt;/p&gt;
&lt;h2 id=&#34;fucntion-overloading&#34;&gt;Fucntion Overloading&lt;/h2&gt;
&lt;p&gt;Function polymorphism is a neat C++ addition to C&amp;rsquo;s capabilities. Whereas default arguments lets you call the same function by using varing numbers of arguments, function polymorphism, also called function overloading, lets you use multiple function sharing the same name. The word polymorphism means having many forms, so function polymorphism lets a function have many forms. Similarly, the expression function overloading means you can attach more than one function to the same name, thus overloading the name. Both expressions boils down to the same thing, but we&amp;rsquo;ll  usually use the expression function overloading. You can use function overloading to design a family of functions that do essentially the same thing but using different argument lists.&lt;/p&gt;
&lt;p&gt;The key to function overloading is function&amp;rsquo;s argument list, also called the &lt;strong&gt;function signature.&lt;/strong&gt; If two function use the same number and types of arguments in the same order, they have the same signature; the variable names don&amp;rsquo;t matter. C++ enables you to define two functions by the same name, providede that the functions have different signatures. The signature can differ in the &lt;strong&gt;number&lt;/strong&gt; of arguments or in the &lt;strong&gt;type&lt;/strong&gt; of arguments, or both.&lt;/p&gt;
&lt;p&gt;When yyou use overloaded functions, you need to be sure you use the proper argument types in the function call.&lt;/p&gt;
&lt;p&gt;Note some signatures that appear to be different from each other nonetheless can&amp;rsquo;t coexist, for example, consider these two prototypes:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cube&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; x);
&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;cube&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; x);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When the compiler checks function signatures, it considers a reference to a type and the type itself to be the same signature.&lt;/p&gt;
&lt;p&gt;The function-matching process does discriminate between const and non-const variable. Consider the following prototypes:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dabble&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; bits);
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;drivel&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; bits);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The dabble() function only matches a call with a non-const argument, but the drivel() function matches calls with either const or non-const arguments. The reason for this difference in behavior between drivel() and dabble() is that it&amp;rsquo;s valid to assign a non-const value to a const variable, but not vice versa.&lt;/p&gt;
&lt;p&gt;Keep in mind that the signature, not the function type, enables function overloading. For example, the following two declarations are incompatible:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;gronk&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; m);	&lt;span style=&#34;color:#75715e&#34;&gt;//same signatures,
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;gronk&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n, &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; m);	&lt;span style=&#34;color:#75715e&#34;&gt;// hence not allowed
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Overloading Reference Parameters&lt;/strong&gt;&lt;/em&gt;:&lt;/p&gt;
&lt;p&gt;Class designs and the STL often use reference parameters, and it&amp;rsquo;s useful to know how overloading works with different reference types. Consider the following three prototypes:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sink&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; r1);	&lt;span style=&#34;color:#75715e&#34;&gt;//matches modifiable lvalue
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sank&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; r2);	&lt;span style=&#34;color:#75715e&#34;&gt;//matches modifiable or const lvalue, rvalue
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sunk&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; r3);	&lt;span style=&#34;color:#75715e&#34;&gt;//matches rvalue
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The lvalue reference parameter r1 matches a modifiable lvalue argument, such as a double variable. The const lvalue reference parameter r2 mattches a modifiable lvalue argument, a const lvalue argument, and an rvalue argument, such as the sum of two double values. Finally, the rvalue reference r3 matches an rvalue. Note how r2 can match the same sort of arguments that r1 and r3 match. This raises the question of what happens when you overload a function on these three types of parameters. &lt;strong&gt;The answer is that the more exact match is made:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;staff&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; rs);	&lt;span style=&#34;color:#75715e&#34;&gt;//matches modifiable lvalue
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;staff&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; rcs);	&lt;span style=&#34;color:#75715e&#34;&gt;//matches rvalue, const lvalue
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;stove&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; r1);	&lt;span style=&#34;color:#75715e&#34;&gt;//matches modifiable lvalue
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;stove&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; r2);	&lt;span style=&#34;color:#75715e&#34;&gt;//matches const lvalue
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;stove&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; r3);	&lt;span style=&#34;color:#75715e&#34;&gt;//matches rvalue
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;function-template&#34;&gt;Function Template&lt;/h2&gt;
&lt;p&gt;A function template is a generic function description; that is, it defines a function in terms of a generic type for which a specific type, such as int or double, can be substituded. By passing a type as a parameter to a template, you cause the compiler to genarate a function for that particular type. Because templates let you program in terms of a generic type instead of a specific type, the process is sometimes termed generic programming. Because types are represented by parameters, the template feature is sometimes referred to as &lt;strong&gt;parameterized types&lt;/strong&gt;.
Function templates enable you to define a function in terms of some arbitrary type. For example, you can set up a swapping template like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; AnyType&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Swap(AnyType &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a, Anytype &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;b)
{
	Anytype temp;
	temp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a;
	a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;b;
	b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;temp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The keywords template and typename are obligatory, except that you can use the keyword class instead of typename. Also you must use the angle brackets. The template does not create any function. Instead, it provides the compiler with direction about how to define a function.
Before the C++98 Standard added the keyword typename to the language, C++ used the keyword class in this pariticular context. That is, you can write the template definition this way:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AnyType&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Swap(AnyType &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a, AnyType &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;b)
{
	AnyType temp;
	temp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a;
	a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;b;
	b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;temp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The C++ Standard treats the two keywords identically when they are used in this context.
&lt;em&gt;&lt;strong&gt;Tip:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;You should use templates if you need functions that apply the same algorithm to a variety of types. If you aren&amp;rsquo;t concerned with backward compatibility and can put up with the effort of typing a longer word, you can use the keyword typename rather than class when you declare type parameter.&lt;/p&gt;
&lt;h3 id=&#34;overloaded-templates&#34;&gt;Overloaded Templates&lt;/h3&gt;
&lt;p&gt;You use template when you need functions that apply the same algorithm to a variety of types.However, that not all types would use the same algorithm. To handle this possibility, you can overload template definitions. For instance:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//twotemps.cpp -- using overloaded template functions
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// original template
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Swap(T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a, T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;b);

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// new template
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Swap(T &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;a, T &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;b, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n);
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;()
{
	...
	...
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Swap(T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;a, T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;b)
{
	T temp;
	temp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a;
	a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;b;
	b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;temp;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Swap(T a[], T b[], &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; n)
{
	T temp;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;n; i&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;)
	{
		temp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a[i];
		a[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;b[i];
		b[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;temp;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;explicit-specializations&#34;&gt;Explicit Specializations&lt;/h4&gt;
&lt;p&gt;If the compiler finds a specified difinition that exactly matches a function call, it uses that definition without looking for templates.&lt;/p&gt;
&lt;h5 id=&#34;third-generation-specializationisoansi-c-standard&#34;&gt;Third-Generation Specialization(ISO/ANSI C++ Standard)&lt;/h5&gt;
&lt;p&gt;After some experimentation with other approach, the C++98 Standard setted on this approach:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For a given function name, you can have a non template function, a template function, and an explicit specification template function, along with overloaded versions of all of these.&lt;/li&gt;
&lt;li&gt;The prototype and definition for an explicit specialication shoud be proceded by template &amp;lt;&amp;gt; and should mention the specialized type by name.&lt;/li&gt;
&lt;li&gt;A specialization overrides the regular template, and a non template function overrides both.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here&amp;rsquo;s how prototypes for swapping type job structures would look for these forms:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// non template function prototype
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Swap&lt;/span&gt;(job &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;, job &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;);

&lt;span style=&#34;color:#75715e&#34;&gt;// template prototype
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typename&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Swap(T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;, T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;);

&lt;span style=&#34;color:#75715e&#34;&gt;// explicit specialization for the job type
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Swap&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;job&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(job &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;, job &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note: Non template version &amp;gt; Explicit specialization version &amp;gt; template version&lt;/p&gt;
&lt;p&gt;In addition, the &lt;!-- raw HTML omitted --&gt; in Swap(job) is optional because the function argument types indicates that this is a secification for job. Thus, the prototype can be written this way:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template &amp;lt;&amp;gt; void Swap(job &amp;amp;, job &amp;amp;);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;instantiations-and-specializations&#34;&gt;Instantiations and specializations&lt;/h4&gt;
&lt;p&gt;Keep in mind that including a function template in you code does not in itself generate a function definition. It&amp;rsquo;s merely a plan for generating a function definition for a particular type, the result is termed an instantiation of the template. The template is not a function definition, but the specific instantiation using int is a function definition. This type of instantiation is termed implicit instantiation because the compiler deduces the necessity for making the definition by noting that the program uses a Swap() function with int paramaters. However, now C++ allows for explicit instantiation. That means you can instruct the compiler to create a particular instantiation &amp;ndash; for example, Swap&lt;!-- raw HTML omitted --&gt;() &amp;ndash; directly. The syntax is to declare the particular variety you want, using the &amp;lt;&amp;gt; notation to indicate the type and prefixing the declaration with the keyword template:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Swap&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;//explicit instantiation
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;template &amp;lt;&amp;gt; void Swap&amp;lt;int&amp;gt;(int &amp;amp;, int &amp;amp;);	//explicit specialization
template &amp;lt;&amp;gt; void Swap(int &amp;amp;, int &amp;amp;);	//explicit specialization
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The explicit specialization declaration has &amp;lt;&amp;gt; after the keyword termplate, whereas the explicit instantiation omits the &amp;lt;&amp;gt;.&lt;/p&gt;
&lt;p&gt;**Caution:**It is an error to try to use both an explicit instantiation and an explicit specialization for the same type(s) in the same file, or, more generally, the same translation unit.&lt;/p&gt;
&lt;p&gt;Implicit instantiations, explicit instantiations, and explicit specializations collectively are termed &lt;em&gt;specializations&lt;/em&gt;. What they all have in common is that they represent a function definition that uses specific types rather than one that is a generic description.
The following fragment summaries the main concept:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;...
&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Swap(T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;, T &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;);	&lt;span style=&#34;color:#75715e&#34;&gt;// template prototype
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Swap&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;job&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(job &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;, job &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;);	&lt;span style=&#34;color:#75715e&#34;&gt;// explicit specialization for job
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; Swap&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;//explicit instantiation for char
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;short&lt;/span&gt; a, b;
	...
	Swap(a,b);	&lt;span style=&#34;color:#75715e&#34;&gt;//implicit template instantiation for short
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	job n, m;
	...
	Swap(n, m);	&lt;span style=&#34;color:#75715e&#34;&gt;//use explicit specialization for job
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; g, h;
	...
	Swap(g, h);	&lt;span style=&#34;color:#75715e&#34;&gt;//use explicit template instantiation for char
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;which-function-version-does-the-compiler-pickoverload-resolution&#34;&gt;Which Function Version Does the Compiler Pick?(overload resolution)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Phase 1&lt;/strong&gt; &amp;ndash; Assemble a list of candidate function. These are functions and template function that have the same names as the called the called functions.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Phase 2&lt;/strong&gt; &amp;ndash; From the candidate functions, assemble a list of viableï¼ˆåˆ‡å®å¯è¡Œçš„ï¼‰ function. These are functions with the correct number of arguments and for which there is implicit conversion sequence, which includes the case of an exact match of each type of actual argument to the type of the corresponding formal argument. For example, a function call with a type &lt;code&gt;float&lt;/code&gt; argument could have that value converted to a &lt;code&gt;double&lt;/code&gt; to match a type &lt;code&gt;double&lt;/code&gt; formal parameter, and a template could generate an instantiation for &lt;code&gt;float&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Phase 3&lt;/strong&gt; &amp;ndash; Determine whether there is a best viable function. If so, you use that function. Otherwise, the function call is an error.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;extract-matches-an-best-matches&#34;&gt;Extract Matches an Best Matches&lt;/h4&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Trival Conversations Allowed for an Extract Match&lt;/strong&gt;&lt;/em&gt;
| From an Actual Argument | To a Formal Argument|
| &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;	| &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|
| Type			| Type &amp;amp; 		|
| Type &amp;amp;		| Type			|
| Type []		| * Type		|
| Type(argument-list)	| Type(*)(argument-list	|
| Type			| const Type		|
| Type			| volatile Type		|
| Type *		| const Type *		|
| Type *		| volatile Type *	|&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt; The overload resolution process look for a function that&amp;rsquo;s the best match. If there&amp;rsquo;s just one, that function is chosen. If more than one are otherwise tied, but only one is a non template, that non template function is chosen. If more than one candidate are otherwise tied and all are  template functions, but one template is more specialized than the rest, that one is chosen. If there are two or more equally good non template functions, or if there are two or more equally good template functions, none is which is more specified than the rest, the function call is ambiguous and an error. If there are non matching calls, of course, that&amp;rsquo;s also an error.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/em&gt; As with regular functions, a template function definition can act as its own prototype if it appears before the function is used.&lt;/p&gt;
&lt;h3 id=&#34;template-function-evolution&#34;&gt;Template Function Evolution&lt;/h3&gt;
&lt;p&gt;One problem is that when you write a template function, it&amp;rsquo;s not always possible in C++98 to know what type to use in a declaration. Consider this example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T1&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; ft(T1 x, T2 y)
{
	...
	&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;type&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; xpy&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y;
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;What should the type for xyp be?&lt;/p&gt;
&lt;h4 id=&#34;the-decltype-keywordc11&#34;&gt;The &lt;code&gt;decltype&lt;/code&gt; Keyword(C++11)&lt;/h4&gt;
&lt;p&gt;The C++11 solution for the above problem is a new keyword:&lt;code&gt;decltype&lt;/code&gt;. It can be used in this way:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x;
&lt;span style=&#34;color:#66d9ef&#34;&gt;decltype&lt;/span&gt;(x) y;	&lt;span style=&#34;color:#75715e&#34;&gt;// make y the same type as x
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The argument to &lt;code&gt;decltype&lt;/code&gt; can be an expression, so in the &lt;code&gt;ft()&lt;/code&gt; example, wwe could use this code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;decltype&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y) xpy;	&lt;span style=&#34;color:#75715e&#34;&gt;// make xpy the same as x+y
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;xpy&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For the &lt;code&gt;decltype&lt;/code&gt; facility, the compiler has to go through a checklist to decide on the type. Suppose we have the following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;decltype&lt;/span&gt;(expression) var
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here are somewhat simplified version of the list:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stage 1: If &lt;code&gt;expression&lt;/code&gt; is an unparenthesized identifier(that is, no additional parentheses), then &lt;code&gt;var&lt;/code&gt; is of the same type as the identifier, including such as &lt;code&gt;const&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Stage 2: If &lt;code&gt;expression&lt;/code&gt; is a function call, then &lt;code&gt;var&lt;/code&gt; has the type of the function return type.&lt;/li&gt;
&lt;li&gt;Stage 3: If &lt;code&gt;expression&lt;/code&gt; is an lvalue, then &lt;code&gt;var&lt;/code&gt; is a reference to the expression type.(p440)&lt;/li&gt;
&lt;li&gt;Stage 4: If none of the preceding special cases apply, &lt;code&gt;var&lt;/code&gt; is of the same type as &lt;code&gt;expression&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you need more than one declaration, you can use &lt;code&gt;typedef&lt;/code&gt; with &lt;code&gt;decltype&lt;/code&gt;, such as&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decltype&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y) xytype;
xytype xpy&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y;
xytype arr[&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;];
xytype &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; rxy &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; arr[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;];	&lt;span style=&#34;color:#75715e&#34;&gt;// rxy a reference
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;alternative-function-syntaxc11-trailing-return-type&#34;&gt;Alternative Function Syntax(C++11 Trailing Return Type)&lt;/h4&gt;
&lt;p&gt;Due to the &lt;code&gt;decltype&lt;/code&gt; specifier has to come after the parameters are declared, the &lt;code&gt;decltype&lt;/code&gt; mechanism by itself leaves another related problem unsolved. Consider this incomplete template function:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T1&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;type&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; gt(T1 x, T2 y)
{
	...
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Again, we don&amp;rsquo;t know in advance what type results from adding x and y.
C++11 allows a new syntax for declaring and defining functions. Here&amp;rsquo;s how it works using built-in type. The prototype:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; y);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;can be written with this alternative syntax:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; y) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The same form could be used with the function definition:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;{&lt;span style=&#34;color:#75715e&#34;&gt;/* function body*/&lt;/span&gt;}
&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; h(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x, &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; y) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;double&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Combining this syntax with &lt;code&gt;decltype&lt;/code&gt; leads to the following solution for specifying the return type for &lt;code&gt;gt()&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T1&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;T2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;auto&lt;/span&gt; gt(T1 x, T2 y) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;decltype&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y)
{
	...
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;
&lt;p&gt;C++ has expanded C function capabilities. By using an inline keyword with a function definition and by placing that definition ahead of the first call to that function, you suggest to the C++ compiler that it make the function inline. That is, instead of having the program jump to a separate section of code to execute the function, the compiler replaces the function call with the corresponding code inline. An inline facility should be used only when the function is short.
A reference variable is a kind of disguised(ä¼ªè£…çš„ï¼‰ pointer that lets you create an alias(that is, a second name) for a variable. Reference variables are primarily used as arguments to functions that process structure and class object. Normally, an identifier declared as a reference to a particular type can refer only to data of that type. However, when one class is derived from another, such as &lt;code&gt;ofstream&lt;/code&gt; from &lt;code&gt;ostream&lt;/code&gt;, a reference to the base type may also refer to the derived type.
C++ prototypes enable you to define default values for arguments. If a function call omits the corresponding argument, the program uses the default value. If a function includes an argument value, the program uses that value instead of the default. Default argument can be provided only from right to left in the argument list. Thus, if you provide a default value for a particular argument, you must also provide default value to the right of that argument.
A function&amp;rsquo;s signature is its argument list. You can define two functions having the same name, provided that they have different signatures. This is called &lt;code&gt;function polymorphism&lt;/code&gt;, or &lt;code&gt;function overloading&lt;/code&gt;. Typically, you overload functions to provide essentially the same service to different types.
Function templates automate the process of overloading function. You define a function by using a generic type and a particular algorithm, and the compiler generates appropriate function definitions for the particular argument types you use in a program.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>æ˜¥ä¹‹æ€</title>
      <link>https://binghuacheng.github.io/posts/%E6%98%A5%E4%B9%8B%E6%80%9D/</link>
      <pubDate>Sat, 02 May 2020 14:04:05 +0000</pubDate>
      
      <guid>https://binghuacheng.github.io/posts/%E6%98%A5%E4%B9%8B%E6%80%9D/</guid>
      <description>&lt;p&gt;åœ¨æ–°å† ç–«æƒ…å½±å“ä¸‹ï¼Œå·²ç»åœ¨å®¶æ··äº†å‡ ä¸ªæœˆäº†ï¼Œé™¤äº†æ— èŠæ„Ÿå†æ— å…¶ä»–æƒ³æ³•ï¼Œæ„Ÿè§‰è‡ªå·±æˆ–è®¸ä»Šç”Ÿå°±åªèƒ½å¦‚æ­¤äº†ï¼Œåªèƒ½åœ¨è¿™ç§æ— èŠæ„Ÿä¸­è™šåº¦æœªæ¥çš„å¹´åäº†ã€‚äº¦æ›¾è¯•å›¾åšå‡ºæ”¹å˜ï¼Œä½†å¾€å¾€åšæŒä¸äº†å‡ å¤©ã€‚
åœ¨é«˜ä¸­æ—¶ä¾¿æ˜¯ä¸€ä¸ªæå…¶å›é€†çš„äººï¼Œåœ¨é‚£äº›æ‰€è°“çš„æ”¹å˜å‘½è¿çš„æ—¶åˆ»ï¼Œæ€»æ˜¯ä¹ æƒ¯æ€§åœ°ä½œæ­»ï¼Œäºæ˜¯ä¾¿æœ‰äº†é«˜ä¸‰æœ€åå‡ ä¸ªæœˆçš„é€€å­¦ã€‚é‚£å‡ ä¸ªæœˆçš„è®°å¿†ä¸ç°åœ¨æ˜¯å¦‚æ­¤ç›¸ä¼¼ &amp;ndash; æ— èŠï¼Œçƒ¦èºï¼Œå”¯ä¸€ä¸åŒä¹‹å¤„æˆ–è®¸æ˜¯ç°åœ¨æ²¡æœ‰é‚£ä¹ˆå¼ºçƒˆçš„è¢«ä¸–ç•Œé—å¼ƒçš„æ„Ÿè§‰ã€‚
åœ¨æ­¤åˆ»ï¼Œäº”æœˆï¼Œä¸é‚£æ—¶æ—¶é—´å‡ è¿‘é‡å ï¼Œå†åŠ ä¸Šé‚£è®©äººæ¼ç«çš„èŠ±ç²‰è¿‡æ•ï¼Œè®©äººåˆå¾ˆæ˜¯éƒé—·ã€‚&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>å¼€è®¾æœ¬åšå®¢çš„ç›®çš„</title>
      <link>https://binghuacheng.github.io/posts/%E5%BC%80%E8%AE%BE%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%9B%AE%E7%9A%84/</link>
      <pubDate>Thu, 30 Apr 2020 17:47:16 +0000</pubDate>
      
      <guid>https://binghuacheng.github.io/posts/%E5%BC%80%E8%AE%BE%E6%9C%AC%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%9B%AE%E7%9A%84/</guid>
      <description>&lt;p&gt;ä¸€ç›´ä»¥æ¥éƒ½æœ‰ç€å¾ˆå·®çš„é˜…è¯»ä¹ æƒ¯ï¼Œçœ‹è¿‡çš„ä¹¦éƒ½æ˜¯éšéšä¾¿ä¾¿çš„ç¿»ä¸€éï¼Œæ²¡æœ‰åšç¬”è®°ä¸ä¹¦è¯„çš„ä¹ æƒ¯ï¼Œæ•…è™½çœ‹è¿‡ä¸å°‘ä¹¦ï¼Œå½“å¤§éƒ½æ˜¯çœ‹åå³å¿˜ï¼Œæ•…æƒ³é€šè¿‡å¼€è®¾æ­¤åšå®¢çš„æ–¹å¼ï¼Œå°†ä»¥å‰çœ‹è¿‡çš„ä¹¦çš†å†çœ‹ä¸€éï¼Œæ•´ç†å…¶è„‰ç»œï¼Œå¹¶å¼ºè¿«è‡ªå·±å°†ä»¥åå°†çœ‹çš„ä¹¦çš†é€šè¿‡æ­¤æ–¹å¼åŠ å¼ºè®°å¿†ã€‚ç”±äºä¸ªäººæ°´å¹³æœ‰é™ï¼Œå¯èƒ½ä¼šæœ‰è¯¸å¤šé”™è¯¯ã€‚
Please forgive that.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>